<!DOCTYPE html>
<html>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Aspects源码分析</title>
    <meta name="description" content="Freelf's Blog" />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="//Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="面向自由编程" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Aspects源码分析" />
    <meta property="og:description" content="Freelf's Blog" />
    <meta property="og:url" content="//Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Aspects源码分析" />
    <meta name="twitter:description" content="Freelf's Blog" />
    <meta name="twitter:url" content="//Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "面向自由编程",
    "name": "Aspects源码分析",
    "url": "//Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90",
    "image": "/assets/images/cover1.jpg",
    "description": "Freelf's Blog"
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="面向自由编程" href="/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/about">About</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->
<!-- The comment above "< default" means - insert everything in this file into -->
<!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data fom the post -->
<!-- #post -->
<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        <a class="back-button icon-arrow-left" href="/">Home</a>
        <a class="menu-button icon-menu" href="#"><span class="word">Menu</span></a>
    </nav>
</header>

<main class="content" role="main">

    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Aspects源码分析</h1>
            <section class="post-meta">
                <!-- <a href='/'>Freelf</a> -->

                
                
                <!-- <a href='/author/Freelf'>Freelf</a> -->
                
                
                <time class="post-date"
                    datetime="2020-12-09">09 Dec 2020</time>
                <!-- [[tags prefix=" on "]] -->
                
                <!-- on -->
                
                
                <a href='/tag/iOS'>iOS</a>
                
                
                
            </section>
        </header>

        <section class="post-content">

            <p>最近有个需求用到了Aspects这个库，用的过程中发现了一些问题，为了解决问题，花了几天时间精读了一遍Aspects的源码。读的过程中发现这个库如果发散着去读，可以了解Objective-C这个语言的方方面面。这篇文章就不发散了，本篇集中记录Aspects如何去进行Hook方法的。后面可能会写一些Aspects发散的文章。本篇分析采用从入口方法开始，然后用到哪个方法会分析哪个方法。</p>

<h2 id="aspects入口方法">Aspects入口方法</h2>
<p>Aspects为<code class="highlighter-rouge">NSObject</code>写了一个分类，添加了两个方法，一个是类方法，一个是实例方法，方法名都一样，具体方法如下：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">+</span> <span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">aspect_hookSelector</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">selector</span>
                           <span class="nf">withOptions</span><span class="p">:(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="nv">options</span>
                            <span class="nf">usingBlock</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">block</span>
                                 <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">aspect_hookSelector</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">selector</span>
                           <span class="nf">withOptions</span><span class="p">:(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="nv">options</span>
                            <span class="nf">usingBlock</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">block</span>
                                 <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</code></pre></div></div>
<p>这两个方法都直接调用了<code class="highlighter-rouge">aspect_add</code>方法，这个方法才是hook的真正入口，这个方法的实现如下：</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">id</span> <span class="nf">aspect_add</span><span class="p">(</span><span class="n">id</span> <span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">AspectOptions</span> <span class="n">options</span><span class="p">,</span> <span class="n">id</span> <span class="n">block</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>

    <span class="n">__block</span> <span class="n">AspectIdentifier</span> <span class="o">*</span><span class="n">identifier</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="c1">// 1. 加锁，保证线程安全
</span>    <span class="n">aspect_performLocked</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">// 2. 判断是否可以hook
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">aspect_isSelectorAllowedAndTrack</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 3.1 获取aspect容器
</span>            <span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">aspectContainer</span> <span class="o">=</span> <span class="n">aspect_getContainerForObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
            <span class="c1">//3.2 生成aspect标识，每个标识对应一个aspect
</span>            <span class="n">identifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">AspectIdentifier</span> <span class="nf">identifierWithSelector</span><span class="p">:</span><span class="n">selector</span> <span class="nf">object</span><span class="p">:</span><span class="n">self</span> <span class="n">options</span><span class="o">:</span><span class="n">options</span> <span class="n">block</span><span class="o">:</span><span class="n">block</span> <span class="n">error</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">identifier</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//3.3 将aspect添加到容器里面
</span>                <span class="p">[</span><span class="n">aspectContainer</span> <span class="nf">addAspect</span><span class="p">:</span><span class="n">identifier</span> <span class="nf">withOptions</span><span class="p">:</span><span class="n">options</span><span class="p">];</span>
                <span class="c1">// 4.进行hook
</span>                <span class="n">aspect_prepareClassAndHookSelector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">identifier</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>通过这个入口方法可以了解到添加一个hook的具体过程，具体过程如下：</p>
<ol>
  <li>先加锁保证线程安全(这里如果发散的话，其实可以了解一下iOS中的各种锁)。</li>
  <li>判断是否可以添加hook</li>
  <li>如果可以hook的话，创建对应的aspect标识，如果标识创建成功，添加到容器，进行下一流程。</li>
  <li>进行hook</li>
</ol>

<p>用一张图来表示整个流程的话就如下图所示：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2020/12/09/hook-guo-cheng.png" alt="hook过程" /></p>

<h2 id="aspect_performlocked">aspect_performLocked</h2>
<p><code class="highlighter-rouge">aspect_performLocked</code>这个方法很简单，就是一个加锁的方法，代码如下：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">aspect_performLocked</span><span class="p">(</span><span class="n">dispatch_block_t</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">OSSpinLock</span> <span class="n">aspect_lock</span> <span class="o">=</span> <span class="n">OS_SPINLOCK_INIT</span><span class="p">;</span>
    <span class="n">OSSpinLockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aspect_lock</span><span class="p">);</span>
    <span class="n">block</span><span class="p">();</span>
    <span class="n">OSSpinLockUnlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aspect_lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里使用了<code class="highlighter-rouge">OSSpinLock</code>，这是个自旋锁，关于锁的知识，这里不展开讲，后面可能会专门写文章去研究锁。这个方法主要保证我们添加aspect时的线程安全。</p>
<h2 id="aspect_isselectorallowedandtrack">aspect_isSelectorAllowedAndTrack</h2>
<p><code class="highlighter-rouge">aspect_isSelectorAllowedAndTrack</code>这个方法是检查是否可以添加aspect。代码比较长，这里逐步进行分析。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">NSSet</span> <span class="o">*</span><span class="n">disallowedSelectorList</span><span class="p">;</span>
<span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">pred</span><span class="p">;</span>
<span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">disallowedSelectorList</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSSet</span> <span class="nf">setWithObjects</span><span class="p">:</span><span class="s">@"retain"</span><span class="p">,</span> <span class="s">@"release"</span><span class="p">,</span> <span class="s">@"autorelease"</span><span class="p">,</span> <span class="s">@"forwardInvocation:"</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
<span class="p">});</span>

<span class="c1">// Check against the blacklist.
</span><span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
<span class="k">if</span> <span class="p">([</span><span class="n">disallowedSelectorList</span> <span class="nf">containsObject</span><span class="p">:</span><span class="n">selectorName</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorDescription</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Selector %@ is blacklisted."</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">];</span>
    <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorSelectorBlacklisted</span><span class="p">,</span> <span class="n">errorDescription</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里创建了一个不允许hook的方法集合，如果要hook的方法在集合中，直接返回<code class="highlighter-rouge">NO</code>，不允许hook。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Additional checks.
</span><span class="n">AspectOptions</span> <span class="n">position</span> <span class="o">=</span> <span class="n">options</span><span class="o">&amp;</span><span class="n">AspectPositionFilter</span><span class="p">;</span>
<span class="c1">// dealloc 只允许option为before时hook
</span><span class="k">if</span> <span class="p">([</span><span class="n">selectorName</span> <span class="nf">isEqualToString</span><span class="p">:</span><span class="s">@"dealloc"</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">position</span> <span class="o">!=</span> <span class="n">AspectPositionBefore</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorDesc</span> <span class="o">=</span> <span class="s">@"AspectPositionBefore is the only valid position when hooking dealloc."</span><span class="p">;</span>
    <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorSelectorDeallocPosition</span><span class="p">,</span> <span class="n">errorDesc</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里对hook <code class="highlighter-rouge">dealloc</code>方法做了判断，<code class="highlighter-rouge">dealloc</code>方法只允许在option为<code class="highlighter-rouge">AspectPositionBefore</code>时才允许hook。</p>
<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">self</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">class</span> <span class="nf">instancesRespondToSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 查看类中是否有hook的方法
</span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorDesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Unable to find selector -[%@ %@]."</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">),</span> <span class="n">selectorName</span><span class="p">];</span>
    <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorDoesNotRespondToSelector</span><span class="p">,</span> <span class="n">errorDesc</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果当前类没有响应要hook的方法，直接返回<code class="highlighter-rouge">NO</code>不允许hook。</p>

<p>接下来有个判断，<code class="highlighter-rouge">class_isMetaClass(object_getClass(self))</code>，<code class="highlighter-rouge">object_getClass</code>是获取当前类的<code class="highlighter-rouge">isa</code>指针指向的对象。如果当前类的<code class="highlighter-rouge">isa</code>是元类就会进行下面一系列检查。Objective-C中只有类对象的<code class="highlighter-rouge">isa</code>指向元类。所以如果调用hook方法的是一个实例对象，这里直接返回<code class="highlighter-rouge">YES</code>。如果是类对象这里要进行判断。加这个判断的主要是为了保证在类继承体系上只允许对一个方法进行一次hook。下面来看一下是如何保证的：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">klass</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
<span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">swizzledClassesDict</span> <span class="o">=</span> <span class="n">aspect_getSwizzledClassesDict</span><span class="p">();</span>
<span class="n">Class</span> <span class="n">currentClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
</code></pre></div></div>
<p>这里声明了3个变量，其中<code class="highlighter-rouge">klass</code>和<code class="highlighter-rouge">currentClass</code>都代表当前类。<code class="highlighter-rouge">swizzledClassesDict</code>是一个可变的字典。获取可变字典通过一个函数获取的，代码如下：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="nf">aspect_getSwizzledClassesDict</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">swizzledClassesDict</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">pred</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">swizzledClassesDict</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nf">new</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">swizzledClassesDict</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>接下来看下面的代码用到了一个类<code class="highlighter-rouge">AspectTracker</code>， 先来看一下<code class="highlighter-rouge">AspectTracker</code>的实现，<code class="highlighter-rouge">AspectTracker</code>的实现很简单，对应的方法在下面代码中已经标明注释</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AspectTracker interface
</span><span class="k">@interface</span> <span class="nc">AspectTracker</span> <span class="p">:</span> <span class="nc">NSObject</span>
<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithTrackedClass</span><span class="p">:(</span><span class="n">Class</span><span class="p">)</span><span class="nv">trackedClass</span><span class="p">;</span>
<span class="c1">// 当前tracker的类
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">Class</span> <span class="n">trackedClass</span><span class="p">;</span>
<span class="c1">// 当前tracker对应的类名
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">readonly</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">trackedClassName</span><span class="p">;</span>
<span class="c1">// 当前类hook的方法名
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">selectorNames</span><span class="p">;</span>
<span class="c1">// 记录tracker类子类的tracker，key是selectorName，value是set
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">;</span>
<span class="c1">// 添加对应selectorName方法的子类tracker
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addSubclassTracker</span><span class="p">:(</span><span class="n">AspectTracker</span> <span class="o">*</span><span class="p">)</span><span class="nv">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span><span class="p">;</span>
<span class="c1">// 移除对应selectorName方法的子类tracker
</span><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSubclassTracker</span><span class="p">:(</span><span class="n">AspectTracker</span> <span class="o">*</span><span class="p">)</span><span class="nv">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span><span class="p">;</span>
<span class="c1">// 判断子类是否hook了当前方法
</span><span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">subclassHasHookedSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span><span class="p">;</span>
<span class="c1">// 获取当前类对应selectorName的子类tracker
</span><span class="k">-</span> <span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nf">subclassTrackersHookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// AspectTracker implementation
</span><span class="k">@implementation</span> <span class="nc">AspectTracker</span>

<span class="k">-</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="nf">initWithTrackedClass</span><span class="p">:(</span><span class="n">Class</span><span class="p">)</span><span class="nv">trackedClass</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">_trackedClass</span> <span class="o">=</span> <span class="n">trackedClass</span><span class="p">;</span>
        <span class="n">_selectorNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">_selectorNamesToSubclassTrackers</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nf">new</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">subclassHasHookedSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">[</span><span class="nf">selectorName</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addSubclassTracker</span><span class="p">:(</span><span class="n">AspectTracker</span> <span class="o">*</span><span class="p">)</span><span class="nv">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span> <span class="p">{</span>
    <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">trackerSet</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">[</span><span class="nf">selectorName</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trackerSet</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">trackerSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">[</span><span class="nf">selectorName</span><span class="p">]</span> <span class="o">=</span> <span class="n">trackerSet</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="n">trackerSet</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">subclassTracker</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSubclassTracker</span><span class="p">:(</span><span class="n">AspectTracker</span> <span class="o">*</span><span class="p">)</span><span class="nv">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span> <span class="p">{</span>
    <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">trackerSet</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">[</span><span class="nf">selectorName</span><span class="p">];</span>
    <span class="p">[</span><span class="n">trackerSet</span> <span class="nf">removeObject</span><span class="p">:</span><span class="n">subclassTracker</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trackerSet</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span> <span class="nf">removeObjectForKey</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nf">subclassTrackersHookingSelectorName</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">selectorName</span> <span class="p">{</span>
    <span class="n">NSMutableSet</span> <span class="o">*</span><span class="n">hookingSubclassTrackers</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableSet</span> <span class="nf">new</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">AspectTracker</span> <span class="o">*</span><span class="n">tracker</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">[</span><span class="nf">selectorName</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">tracker</span><span class="p">.</span><span class="n">selectorNames</span> <span class="nf">containsObject</span><span class="p">:</span><span class="n">selectorName</span><span class="p">])</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">hookingSubclassTrackers</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">tracker</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="p">[</span><span class="n">hookingSubclassTrackers</span> <span class="nf">unionSet</span><span class="p">:[</span><span class="n">tracker</span> <span class="nf">subclassTrackersHookingSelectorName</span><span class="p">:</span><span class="n">selectorName</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">hookingSubclassTrackers</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">trackedClassName</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">trackedClass</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">description</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"&lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&gt;"</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="n">self</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">trackedClass</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNames</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">.</span><span class="n">allKeys</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div></div>
<p>接下来看一下如何使用<code class="highlighter-rouge">AspectTracker</code>的：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AspectTracker</span> <span class="o">*</span><span class="n">tracker</span> <span class="o">=</span> <span class="n">swizzledClassesDict</span><span class="p">[</span><span class="nf">currentClass</span><span class="p">];</span>
<span class="c1">// 先检查子类是否Hook
</span><span class="k">if</span> <span class="p">([</span><span class="n">tracker</span> <span class="nf">subclassHasHookedSelectorName</span><span class="p">:</span><span class="n">selectorName</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">NSSet</span> <span class="o">*</span><span class="n">subclassTracker</span> <span class="o">=</span> <span class="p">[</span><span class="n">tracker</span> <span class="nf">subclassTrackersHookingSelectorName</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
    <span class="n">NSSet</span> <span class="o">*</span><span class="n">subclassNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">subclassTracker</span> <span class="nf">valueForKey</span><span class="p">:</span><span class="s">@"trackedClassName"</span><span class="p">];</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorDescription</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy."</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">,</span> <span class="n">subclassNames</span><span class="p">];</span>
    <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorSelectorAlreadyHookedInClassHierarchy</span><span class="p">,</span> <span class="n">errorDescription</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>先获取当前类的tracker，然后检查当前类的子类是否已经对要进行hook的方法进行了hook，如果已经进行了hook，抛出错误。返回<code class="highlighter-rouge">NO</code>不允许进行hook。如果子类没有进行hook，继续执行以下代码：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 检查父类是否hook
</span><span class="k">do</span> <span class="p">{</span>
    <span class="n">tracker</span> <span class="o">=</span> <span class="n">swizzledClassesDict</span><span class="p">[</span><span class="nf">currentClass</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">tracker</span><span class="p">.</span><span class="n">selectorNames</span> <span class="nf">containsObject</span><span class="p">:</span><span class="n">selectorName</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">klass</span> <span class="o">==</span> <span class="n">currentClass</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Already modified and topmost!
</span>            <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
        <span class="p">}</span>
         <span class="n">NSString</span> <span class="o">*</span><span class="n">errorDescription</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy."</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)];</span>
         <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorSelectorAlreadyHookedInClassHierarchy</span><span class="p">,</span> <span class="n">errorDescription</span><span class="p">);</span>
         <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">currentClass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)));</span> <span class="c1">//遍历所有的父类，直到为nil
</span></code></pre></div></div>
<p>这个方法是从自己开始往父类进行遍历，看看是否进行hook，如果当前类已经hook，返回<code class="highlighter-rouge">YES</code>，允许添加hook，如果是父类已经Hook，抛出错误，返回<code class="highlighter-rouge">NO</code>，不允许hook。</p>

<p>如果代码可以走到下面说明当前类的继承体系上没有类对要进行hook的selector进行过hook，最后肯定返回<code class="highlighter-rouge">YES</code>，只是在返回<code class="highlighter-rouge">YES</code>前需要进行把给当前类添加tracker，并且在父类继承体系上面打标记，标记这个方法已经有类hook过了，当用继承体系其他类进行hook时，在前面两步就可以拦住。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 添加Hook的tracker，当前类和父类继承体系里面的都会添加。hook一个方法只会有一次这里。只有再次hook不同方法时才会再次走这里。
// Add the selector as being modified.
</span><span class="n">currentClass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">;</span>
<span class="n">AspectTracker</span> <span class="o">*</span><span class="n">subclassTracker</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="n">tracker</span> <span class="o">=</span> <span class="n">swizzledClassesDict</span><span class="p">[</span><span class="nf">currentClass</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tracker</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tracker</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AspectTracker</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithTrackedClass</span><span class="p">:</span><span class="n">currentClass</span><span class="p">];</span>
        <span class="n">swizzledClassesDict</span><span class="p">[(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">NSCopying</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">currentClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">subclassTracker</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">tracker</span> <span class="nf">addSubclassTracker</span><span class="p">:</span><span class="n">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">tracker</span><span class="p">.</span><span class="n">selectorNames</span> <span class="nf">addObject</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// All superclasses get marked as having a subclass that is modified.
</span>    <span class="n">subclassTracker</span> <span class="o">=</span> <span class="n">tracker</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">currentClass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)));</span>
</code></pre></div></div>
<h3 id="总结">总结</h3>
<p><code class="highlighter-rouge">aspect_isSelectorAllowedAndTrack</code>这个方法用来判断是否可以为当前类的某个方法添加aspect，主要会进行以下几步验证：</p>
<ol>
  <li>黑名单验证</li>
  <li>dealloc不允许在option为非<code class="highlighter-rouge">AspectPositionBefore</code>的情况下hook</li>
  <li>当前类没有响应该方法</li>
  <li>继承体系上面不允许多个类进行hook</li>
</ol>

<h2 id="进行hook">进行Hook</h2>
<p>如果允许hook，下面进行hook流程。</p>
<h3 id="aspectscontainer">AspectsContainer</h3>
<p>前面代码3.1是先获取aspectContainer，代码比较简单，这里就不进行解释了</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">aspectContainer</span> <span class="o">=</span> <span class="n">aspect_getContainerForObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
<span class="c1">// aspect_getContainerForObject
</span><span class="k">static</span> <span class="n">AspectsContainer</span> <span class="o">*</span><span class="nf">aspect_getContainerForObject</span><span class="p">(</span><span class="n">NSObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">aspectContainer</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aspectContainer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">aspectContainer</span> <span class="o">=</span> <span class="p">[</span><span class="n">AspectsContainer</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">,</span> <span class="n">aspectContainer</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">aspectContainer</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// aspect_aliasForSelector
</span><span class="k">static</span> <span class="n">SEL</span> <span class="nf">aspect_aliasForSelector</span><span class="p">(</span><span class="n">SEL</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NSSelectorFromString</span><span class="p">([</span><span class="n">AspectsMessagePrefix</span> <span class="nf">stringByAppendingFormat</span><span class="p">:</span><span class="s">@"_%@"</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">)]);</span>
<span class="p">}</span>

<span class="c1">// AspectsMessagePrefix
</span><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AspectsMessagePrefix</span> <span class="o">=</span> <span class="s">@"aspects_"</span><span class="p">;</span>
</code></pre></div></div>
<h3 id="aspectidentifier">AspectIdentifier</h3>
<p><code class="highlighter-rouge">AspectIdentifier</code>表示一个aspect，每添加一个aspect，就会生成一个<code class="highlighter-rouge">AspectIdentifier</code>放到<code class="highlighter-rouge">AspectsContainer</code>中。接下来看一下<code class="highlighter-rouge">AspectIdentifier</code>的定义：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Tracks a single aspect.
</span><span class="k">@interface</span> <span class="nc">AspectIdentifier</span> <span class="p">:</span> <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">AspectToken</span><span class="o">&gt;</span>
<span class="c1">// 初始化方法
</span><span class="o">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="n">identifierWithSelector</span><span class="o">:</span><span class="p">(</span><span class="n">SEL</span><span class="p">)</span><span class="n">selector</span> <span class="n">object</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">object</span> <span class="n">options</span><span class="o">:</span><span class="p">(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="n">options</span> <span class="n">block</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">block</span> <span class="n">error</span><span class="o">:</span><span class="p">(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
<span class="c1">// invoke aspect
</span><span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">invokeWithInfo</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">info</span><span class="p">;</span>
<span class="c1">// hook的方法
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">;</span>
<span class="c1">// 要执行的block
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">id</span> <span class="n">block</span><span class="p">;</span>
<span class="c1">// block的方法签名
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">blockSignature</span><span class="p">;</span>
<span class="c1">// hook的对象
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">id</span> <span class="n">object</span><span class="p">;</span>
<span class="c1">// hook的option
</span><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">AspectOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div></div>
<p>从<code class="highlighter-rouge">AspectIdentifier</code>的定义可以看出来，它和添加一个aspect的参数几乎是一一对应的，每添加一个aspect，都会生成一个对应的<code class="highlighter-rouge">AspectIdentifier</code>保存起来，等执行到对应的方法时，取出对应的aspect调用一下。接下来看一下<code class="highlighter-rouge">AspectIdentifier</code>的实现，先看初始化方法：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">identifierWithSelector</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">selector</span> <span class="nf">object</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">options</span><span class="p">:(</span><span class="n">AspectOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">block</span><span class="p">:(</span><span class="n">id</span><span class="p">)</span><span class="nv">block</span> <span class="nf">error</span><span class="p">:(</span><span class="n">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="c1">// 获取block的方法签名
</span>    <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">blockSignature</span> <span class="o">=</span> <span class="n">aspect_blockMethodSignature</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span> <span class="c1">// TODO: check signature compatibility, etc.
</span>    <span class="c1">// 校验block方法签名是否和原方法签名是否兼容
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aspect_isCompatibleBlockSignature</span><span class="p">(</span><span class="n">blockSignature</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AspectIdentifier</span> <span class="o">*</span><span class="n">identifier</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">blockSignature</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="p">[</span><span class="n">AspectIdentifier</span> <span class="nf">new</span><span class="p">];</span>
        <span class="n">identifier</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span><span class="p">;</span>
        <span class="n">identifier</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
        <span class="n">identifier</span><span class="p">.</span><span class="n">blockSignature</span> <span class="o">=</span> <span class="n">blockSignature</span><span class="p">;</span>
        <span class="n">identifier</span><span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
        <span class="n">identifier</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span> <span class="c1">// weak
</span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">identifier</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里有两个地方需要重点讲一下，一个是获取block的方法签名，另外一个是校验block签名是否和原方法签名是否兼容。这两个地方看明白会有利于了解Objective-C的本质。</p>
<h4 id="aspect_blockmethodsignature">aspect_blockMethodSignature</h4>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="nf">aspect_blockMethodSignature</span><span class="p">(</span><span class="n">id</span> <span class="n">block</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 找到desc中的方法签名，生成签名
</span>    <span class="n">AspectBlockRef</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AspectBlockFlagsHasSignature</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"The block %@ doesn't contain a type signature."</span><span class="p">,</span> <span class="n">block</span><span class="p">];</span>
        <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorMissingBlockSignature</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">layout</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AspectBlockFlagsHasCopyDisposeHelpers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
    <span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"The block %@ doesn't has a type signature."</span><span class="p">,</span> <span class="n">block</span><span class="p">];</span>
        <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorMissingBlockSignature</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">desc</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">NSMethodSignature</span> <span class="nf">signatureWithObjCTypes</span><span class="p">:</span><span class="n">signature</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里先把传进来的block强制转换成<code class="highlighter-rouge">AspectBlockRef</code>类型，从这里可以看出，Objective-C中的block其实就是一个对象，接下来看一下<code class="highlighter-rouge">AspectBlockRef</code>的定义：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Block internals.
</span><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">AspectBlockFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">AspectBlockFlagsHasCopyDisposeHelpers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">),</span>
	<span class="n">AspectBlockFlagsHasSignature</span>          <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_AspectBlock</span> <span class="p">{</span>
	<span class="n">__unused</span> <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
	<span class="n">AspectBlockFlags</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__unused</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="n">__unused</span> <span class="o">*</span><span class="n">invoke</span><span class="p">)(</span><span class="k">struct</span> <span class="n">_AspectBlock</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span> <span class="p">...);</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
		<span class="c1">// requires AspectBlockFlagsHasCopyDisposeHelpers
</span>		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
		<span class="c1">// requires AspectBlockFlagsHasSignature
</span>		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">layout</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
	<span class="c1">// imported variables
</span><span class="p">}</span> <span class="o">*</span><span class="n">AspectBlockRef</span><span class="p">;</span>
</code></pre></div></div>
<p>有没有很眼熟，这不就是block的定义么，关于block，后面写一篇专门的文章来讲。这里可以记住，一个block类型在Objective-C中是这样存储的。把传进来的block强制转换成<code class="highlighter-rouge">AspectBlockRef</code>类型，是为了取到其中某个变量的值。</p>

<p>接下来看一下如何取出block的方法签名：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AspectBlockFlagsHasSignature</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"The block %@ doesn't contain a type signature."</span><span class="p">,</span> <span class="n">block</span><span class="p">];</span>
    <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorMissingBlockSignature</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>先根据标志位判断当前block是否有签名，如果没有签名，直接报错。返回nil，这里返回nil会打断整个hook流程，也就是要求传进来的block必须是有签名的。如果是有签名的block，接下来就是取签名的过程：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">layout</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">;</span>
<span class="n">desc</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AspectBlockFlagsHasCopyDisposeHelpers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">desc</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">NSString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"The block %@ doesn't has a type signature."</span><span class="p">,</span> <span class="n">block</span><span class="p">];</span>
     <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorMissingBlockSignature</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
     <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="p">)</span><span class="n">desc</span><span class="p">);</span>
<span class="k">return</span> <span class="p">[</span><span class="n">NSMethodSignature</span> <span class="nf">signatureWithObjCTypes</span><span class="p">:</span><span class="n">signature</span><span class="p">];</span>
</code></pre></div></div>
<p>先取到block中的<code class="highlighter-rouge">descriptor</code>指针，<code class="highlighter-rouge">descriptor</code>指针向下偏移两个<code class="highlighter-rouge">unsigned long int</code>的位置就是<code class="highlighter-rouge">copy</code>函数的地址，接下来判断根据flag判断是否包含<code class="highlighter-rouge">copy</code>和<code class="highlighter-rouge">dispose</code>函数地址，如果包含的话，继续往下偏移两个<code class="highlighter-rouge">void *</code>的大小。这时指针肯定移动到了<code class="highlighter-rouge">const char *signature</code>的地址，如果desc不存在说明block没有类型签名，也会报错，终止hook。desc有值的话，说明有方法签名，最后返回方法签名。</p>

<p>可以通过调试看一下具体的方法签名，通过如下代码进行调试：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">UIViewController</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="n">NSSelectorFromString</span><span class="p">(</span><span class="s">@"dealloc"</span><span class="p">)</span> <span class="nf">withOptions</span><span class="p">:(</span><span class="n">AspectPositionBefore</span> <span class="o">|</span> <span class="n">AspectPositionInstead</span><span class="p">)</span> <span class="n">usingBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">info</span><span class="p">){</span>
     <span class="n">NSLog</span><span class="p">(</span><span class="s">@"TestOne hook"</span><span class="p">);</span>
<span class="p">}</span> <span class="n">error</span><span class="o">:</span><span class="nb">NULL</span><span class="p">];</span>
</code></pre></div></div>

<p>得到的方法签名如下：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">signature</span> <span class="o">=</span> <span class="mh">0x000000010d6379e7</span> <span class="s">"v20@?0@</span><span class="se">\"</span><span class="s">&lt;AspectInfo&gt;</span><span class="se">\"</span><span class="s">8B16"</span>
</code></pre></div></div>
<p>想要看懂这串编码需要了解一些Objective-C中type encodings的知识。在Objective-C中，编译器将每个方法的返回值和参数类型编码为一个字符串，并将这个字符串与方法的selector关联在一起。可以通过<code class="highlighter-rouge">@encode</code>指令来获取类型编码。在Objective-C Runtime Programming Guide中的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>中列举了Objective-C中所有的类型编码：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2020/12/09/16068272563420.jpg" alt="" />
需要注意的是Objective-C不支持<code class="highlighter-rouge">long double</code>类型，<code class="highlighter-rouge">@encode(long double)</code>会返回<code class="highlighter-rouge">d</code>，和<code class="highlighter-rouge">double</code>的类型编码一样。</p>

<p>了解了这些再来看前面block的签名字符串就能看懂了，<code class="highlighter-rouge">"v20@?0@\"&lt;AspectInfo&gt;\"8B16"</code>，<code class="highlighter-rouge">v</code>代表返回值类型是<code class="highlighter-rouge">void</code>，20代表整个函数的偏移，<code class="highlighter-rouge">@?</code>表示block类型，0代表偏移量，<code class="highlighter-rouge">@\"&lt;AspectInfo&gt;\"</code>表示第一个参数是遵守<code class="highlighter-rouge">AspectInfo</code>协议的对象，8代表偏移量，<code class="highlighter-rouge">B</code>表示第二个参数BOOL类型，16是偏移量。</p>

<p>接下来打印一下方法签名， 可以看到type encoding和offset和上面的字符串是对应的(除了<code class="highlighter-rouge">v</code>的不对应，字符串中<code class="highlighter-rouge">v</code>后面的数字应该表示整个函数的偏移，不是相对偏移)。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">NSMethodSignature</span><span class="o">:</span> <span class="mh">0x600000a902a0</span><span class="o">&gt;</span>
    <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">frame</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">224</span>
    <span class="n">is</span> <span class="n">special</span> <span class="k">struct</span> <span class="k">return</span><span class="p">?</span> <span class="nb">NO</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">:</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
        <span class="n">type</span> <span class="n">encoding</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="sc">'v'</span>
        <span class="n">flags</span> <span class="p">{}</span>
        <span class="n">modifiers</span> <span class="p">{}</span>
        <span class="n">frame</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">memory</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">argument</span> <span class="mi">0</span><span class="o">:</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
        <span class="n">type</span> <span class="n">encoding</span> <span class="p">(</span><span class="err">@</span><span class="p">)</span> <span class="err">'@</span><span class="p">?</span><span class="err">'</span>
        <span class="n">flags</span> <span class="err">{</span><span class="n">isObject</span><span class="p">,</span> <span class="n">isBlock</span><span class="err">}</span>
        <span class="n">modifiers</span> <span class="err">{}</span>
        <span class="n">frame</span> <span class="err">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">size</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="err">}</span>
        <span class="n">memory</span> <span class="err">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="err">}</span>
    <span class="n">argument</span> <span class="mi">1</span><span class="p">:</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
        <span class="n">type</span> <span class="n">encoding</span> <span class="p">(</span><span class="err">@</span><span class="p">)</span> <span class="err">'</span><span class="s">@"&lt;AspectInfo&gt;"</span><span class="err">'</span>
        <span class="n">flags</span> <span class="p">{</span><span class="n">isObject</span><span class="p">}</span>
        <span class="n">modifiers</span> <span class="p">{}</span>
        <span class="n">frame</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">offset</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">size</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">memory</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">}</span>
            <span class="n">conforms</span> <span class="n">to</span> <span class="n">protocol</span> <span class="err">'</span><span class="n">AspectInfo</span><span class="err">'</span>
    <span class="n">argument</span> <span class="mi">2</span><span class="o">:</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span> <span class="o">--------</span>
        <span class="n">type</span> <span class="n">encoding</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="sc">'B'</span>
        <span class="n">flags</span> <span class="p">{}</span>
        <span class="n">modifiers</span> <span class="p">{}</span>
        <span class="n">frame</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">offset</span> <span class="n">adjust</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">size</span> <span class="n">adjust</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">}</span>
        <span class="n">memory</span> <span class="p">{</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">}</span>

</code></pre></div></div>
<h4 id="aspect_iscompatibleblocksignature">aspect_isCompatibleBlockSignature</h4>
<p><code class="highlighter-rouge">aspect_isCompatibleBlockSignature</code>这个函数是校验添加的aspect和原来的方法签名是否相同。如果不同，不允许添加aspect。下面来看一下实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">BOOL</span> <span class="nf">aspect_isCompatibleBlockSignature</span><span class="p">(</span><span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">blockSignature</span><span class="p">,</span> <span class="n">id</span> <span class="n">object</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">blockSignature</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>

    <span class="n">BOOL</span> <span class="n">signaturesMatch</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="n">NSMethodSignature</span> <span class="o">*</span><span class="n">methodSignature</span> <span class="o">=</span> <span class="p">[[</span><span class="n">object</span> <span class="nf">class</span><span class="p">]</span> <span class="nf">instanceMethodSignatureForSelector</span><span class="p">:</span><span class="n">selector</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">blockSignature</span><span class="p">.</span><span class="n">numberOfArguments</span> <span class="o">&gt;</span> <span class="n">methodSignature</span><span class="p">.</span><span class="n">numberOfArguments</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">signaturesMatch</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">blockSignature</span><span class="p">.</span><span class="n">numberOfArguments</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">blockType</span> <span class="o">=</span> <span class="p">[</span><span class="n">blockSignature</span> <span class="nf">getArgumentTypeAtIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">blockType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'@'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">signaturesMatch</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// Argument 0 is self/block, argument 1 is SEL or id&lt;AspectInfo&gt;. We start comparing at argument 2.
</span>        <span class="c1">// The block can have less arguments than the method, that's ok.
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">signaturesMatch</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">blockSignature</span><span class="p">.</span><span class="n">numberOfArguments</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">methodType</span> <span class="o">=</span> <span class="p">[</span><span class="n">methodSignature</span> <span class="nf">getArgumentTypeAtIndex</span><span class="p">:</span><span class="n">idx</span><span class="p">];</span>
                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">blockType</span> <span class="o">=</span> <span class="p">[</span><span class="n">blockSignature</span> <span class="nf">getArgumentTypeAtIndex</span><span class="p">:</span><span class="n">idx</span><span class="p">];</span>
                <span class="c1">// Only compare parameter, not the optional type data.
</span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">methodType</span> <span class="o">||</span> <span class="o">!</span><span class="n">blockType</span> <span class="o">||</span> <span class="n">methodType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">blockType</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">signaturesMatch</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signaturesMatch</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">description</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Block signature %@ doesn't match %@."</span><span class="p">,</span> <span class="n">blockSignature</span><span class="p">,</span> <span class="n">methodSignature</span><span class="p">];</span>
        <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorIncompatibleBlockSignature</span><span class="p">,</span> <span class="n">description</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>该方法，先比较参数个数是否相等，如果不相等直接返回<code class="highlighter-rouge">NO</code>，终止hook。接下来再判断第二个参数是否是一个对象，如果不是，直接返回<code class="highlighter-rouge">NO</code>。接下来逐个比较参数，看参数类型是否一样，只有所有参数类型一样，才会返回<code class="highlighter-rouge">YES</code>，这里需要解释一下比较参数为什么从2开始比较。其实注释已经解释的很清楚了，Objective-C方法中有两个隐藏函数，第一个是<code class="highlighter-rouge">self</code>，第二个是<code class="highlighter-rouge">_cmd</code>，所以比较传入参数，需要从2开始比较。</p>

<p>接下来带代码就非常简单了，把传入的参数赋值给自己的属性。</p>

<h3 id="aspect_prepareclassandhookselector">aspect_prepareClassAndHookSelector</h3>
<p>前面的<code class="highlighter-rouge">AspectIdentifier</code>如果可以初始化成功，就会进行hook。<code class="highlighter-rouge">aspect_prepareClassAndHookSelector</code>是hook的核心。接下来看一下这个方法的实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">aspect_prepareClassAndHookSelector</span><span class="p">(</span><span class="n">NSObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">Class</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">aspect_hookClass</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span> <span class="c1">// hook forwardInvocation
</span>    <span class="n">Method</span> <span class="n">targetMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
    <span class="n">IMP</span> <span class="n">targetMethodIMP</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aspect_isMsgForwardIMP</span><span class="p">(</span><span class="n">targetMethodIMP</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// hook 对应的方法
</span>        <span class="c1">// Make a method alias for the existing method implementation, it not already copied.
</span>        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeEncoding</span> <span class="o">=</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
        <span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">klass</span> <span class="nf">instancesRespondToSelector</span><span class="p">:</span><span class="n">aliasSelector</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">__unused</span> <span class="n">BOOL</span> <span class="n">addedAlias</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">),</span> <span class="n">typeEncoding</span><span class="p">);</span>
            <span class="n">NSCAssert</span><span class="p">(</span><span class="n">addedAlias</span><span class="p">,</span> <span class="s">@"Original implementation for %@ is already copied to %@ on %@"</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">),</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">aliasSelector</span><span class="p">),</span> <span class="n">klass</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// We use forwardInvocation to hook in.
</span>        <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">aspect_getMsgForwardIMP</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">),</span> <span class="n">typeEncoding</span><span class="p">);</span>
        <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: Installed hook for -[%@ %@]."</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个方法体现了<code class="highlighter-rouge">Aspects</code>这个库的hook思想，先来简单总结一下。</p>
<ol>
  <li><code class="highlighter-rouge">Aspects</code>是先把类的<code class="highlighter-rouge">forwardInvocation:</code>方法进行hook。</li>
  <li>如果想要对类的某个方法进行Hook，<code class="highlighter-rouge">Aspects</code>会把想要hook的方法实现指向<code class="highlighter-rouge">_objc_msgForward</code>，<code class="highlighter-rouge">_objc_msgForward</code>这个函数是一个汇编标记，标记这个方法需要走消息转发流程。关于这块不明白的可以去看一下Objective-C的消息转发流程。当调用已经hook过的方法时，就会走转发流程，因为<code class="highlighter-rouge">Aspects</code>已经hook了<code class="highlighter-rouge">forwardInvocation:</code>所以就会走<code class="highlighter-rouge">Aspects</code>自己的实现，然后<code class="highlighter-rouge">Aspects</code>在自己实现里面做一些实现。</li>
</ol>

<h4 id="aspect_hookclass">aspect_hookClass</h4>
<p>这个方法是用来hook类的<code class="highlighter-rouge">forwardInvocation:</code>方法，下面来看一下如何hook类的<code class="highlighter-rouge">forwardInvocation:</code>方法。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="n">Class</span> <span class="n">statedClass</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
<span class="n">Class</span> <span class="n">baseClass</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">className</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">baseClass</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">statedClass</code>和<code class="highlighter-rouge">baseClass</code>是有区别的，对于实力对象而言，这两个意义一样。但是对于类对象而言，<code class="highlighter-rouge">statedClass</code>表示自己，<code class="highlighter-rouge">baseClass</code>表示元类。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Already subclassed
// static NSString *const AspectsSubclassSuffix = @"_Aspects_";
</span><span class="k">if</span> <span class="p">([</span><span class="n">className</span> <span class="nf">hasSuffix</span><span class="p">:</span><span class="n">AspectsSubclassSuffix</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">baseClass</span><span class="p">;</span>
    <span class="c1">// We swizzle a class object, not a single object.
</span><span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">class_isMetaClass</span><span class="p">(</span><span class="n">baseClass</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">aspect_swizzleClassInPlace</span><span class="p">((</span><span class="n">Class</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
    <span class="c1">// Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.
</span>    <span class="c1">// baseClass不是元类的话，那么self就是对象，statedClass 和baseClass肯定相等，不相等的话是因为KVO产生了中间类，这种情况对KVO的中间类调用aspect_swizzleClassInPlace
</span><span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">statedClass</span> <span class="o">!=</span> <span class="n">baseClass</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">aspect_swizzleClassInPlace</span><span class="p">(</span><span class="n">baseClass</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果类名里面已经包含了<code class="highlighter-rouge">AspectsSubclassSuffix</code>这个字符串说明已经hook过了。直接返回baseClass。</p>

<p>如果<code class="highlighter-rouge">baseClass</code>是元类，说明<code class="highlighter-rouge">self</code>是类对象，直接进行hook。<code class="highlighter-rouge">aspect_swizzleClassInPlace</code>这个函数作用就是hook类的<code class="highlighter-rouge">forwardInvocation:</code>方法。</p>

<p>如果<code class="highlighter-rouge">baseClass</code>不是元类的话，那么<code class="highlighter-rouge">self</code>就是实例对象，<code class="highlighter-rouge">statedClass</code>和<code class="highlighter-rouge">baseClass</code>肯定是指向同一个地址。不想等的情况只能是KVO产生了中间类。这种情况直接对中间类就行Hook。中间类就是<code class="highlighter-rouge">baseClass</code>。</p>

<p>如果这几个判断条件都没有走，说明self是实例对象，并且没有被KVO过。那么走下面的方法：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 拼接"_Aspects_"字符串
</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">subclassName</span> <span class="o">=</span> <span class="p">[</span><span class="n">className</span> <span class="nf">stringByAppendingString</span><span class="p">:</span><span class="n">AspectsSubclassSuffix</span><span class="p">].</span><span class="n">UTF8String</span><span class="p">;</span>

<span class="n">Class</span> <span class="n">subclass</span> <span class="o">=</span> <span class="n">objc_getClass</span><span class="p">(</span><span class="n">subclassName</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">subclass</span> <span class="o">=</span> <span class="n">objc_allocateClassPair</span><span class="p">(</span><span class="n">baseClass</span><span class="p">,</span> <span class="n">subclassName</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">subclass</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">errrorDesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"objc_allocateClassPair failed to allocate class %s."</span><span class="p">,</span> <span class="n">subclassName</span><span class="p">];</span>
        <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorFailedToAllocateClassPair</span><span class="p">,</span> <span class="n">errrorDesc</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="c1">// swizzle 子类的forwardInvocation
</span>    <span class="n">aspect_swizzleForwardInvocation</span><span class="p">(</span><span class="n">subclass</span><span class="p">);</span>
    <span class="c1">// hook实例class方法
</span>    <span class="n">aspect_hookedGetClass</span><span class="p">(</span><span class="n">subclass</span><span class="p">,</span> <span class="n">statedClass</span><span class="p">);</span>
    <span class="c1">// hook类class方法
</span>    <span class="n">aspect_hookedGetClass</span><span class="p">(</span><span class="n">object_getClass</span><span class="p">(</span><span class="n">subclass</span><span class="p">),</span> <span class="n">statedClass</span><span class="p">);</span>
    <span class="n">objc_registerClassPair</span><span class="p">(</span><span class="n">subclass</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 这里偷偷换了一下，class方法返回statedClass，实际上object_getClass返回新创建的类
// 把当前对象的isa指向自己。
</span><span class="n">object_setClass</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">subclass</span><span class="p">);</span>
<span class="k">return</span> <span class="n">subclass</span><span class="p">;</span>
</code></pre></div></div>
<p>到这里我们可以看到，如果对某个对象的方法进行hook，<code class="highlighter-rouge">Aspects</code>会创建一个对象的子类，在子类的基础上进行操作。这样的好处是不需要修改对象本身的类。当remove aspects的时候，如果发现当前对象的所有aspect都移除了，可以直接将isa指针指向回原来的类。</p>

<p>接下来看一下<code class="highlighter-rouge">Aspects</code>如何创建子类进行hook的。新建类的名字，会先加上<code class="highlighter-rouge">AspectsSubclassSuffix</code>后缀，标记成子类。然后调用<code class="highlighter-rouge">objc_getClass</code>方法，去查找是否已经创建过子类。能来到这里肯定是还没有创建，所以返回的肯定是nil。接下来就会调用objc_allocateClassPair方法创建子类。如果创建失败会报错。终止hook流程。创建成功的话，会走下面的流程。调用<code class="highlighter-rouge">aspect_swizzleForwardInvocation</code>hook新建子类的<code class="highlighter-rouge">forwardInvocation:</code>方法，调用<code class="highlighter-rouge">aspect_hookedGetClass</code>hook子类类的<code class="highlighter-rouge">class</code>方法，返回<code class="highlighter-rouge">statedClass</code>，<code class="highlighter-rouge">statedClass</code>就是原来实例的类对象。调用<code class="highlighter-rouge">aspect_hookedGetClass</code>hook元类的<code class="highlighter-rouge">class</code>方法，返回<code class="highlighter-rouge">statedClass</code>。接下来调用<code class="highlighter-rouge">objc_registerClassPair</code>方法注册新建的子类。最后把原来实例的isa指向新创建的子类。</p>

<h5 id="aspect_swizzleforwardinvocation">aspect_swizzleForwardInvocation</h5>
<p>前面<code class="highlighter-rouge">aspect_hookClass</code>方法中用到了<code class="highlighter-rouge">aspect_swizzleForwardInvocation</code>和<code class="highlighter-rouge">aspect_swizzleClassInPlace</code>方法。<code class="highlighter-rouge">aspect_swizzleClassInPlace</code>最后也是调用了<code class="highlighter-rouge">aspect_swizzleForwardInvocation</code>，只是多了一个加锁的过程。现在来看一下<code class="highlighter-rouge">aspect_swizzleForwardInvocation</code>方法实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AspectsForwardInvocationSelectorName</span> <span class="o">=</span> <span class="s">@"__aspects_forwardInvocation:"</span><span class="p">;</span>
<span class="c1">// swizzling forwardInvocation
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">aspect_swizzleForwardInvocation</span><span class="p">(</span><span class="n">Class</span> <span class="n">klass</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="c1">// If there is no method, replace will act like class_addMethod.
</span>    <span class="n">IMP</span> <span class="n">originalImplementation</span> <span class="o">=</span> <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">forwardInvocation</span><span class="o">:</span><span class="p">),</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="n">__ASPECTS_ARE_BEING_CALLED__</span><span class="p">,</span> <span class="s">"v@:@"</span><span class="p">);</span>
    <span class="c1">// 如果以前类里面已经实现了forwardInvocation，用另一个sel挂住原来的
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">originalImplementation</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">class_addMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="n">AspectsForwardInvocationSelectorName</span><span class="p">),</span> <span class="n">originalImplementation</span><span class="p">,</span> <span class="s">"v@:@"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: %@ is now aspect aware."</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">klass</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>直接调用<code class="highlighter-rouge">class_replaceMethod</code>方法，替换类的<code class="highlighter-rouge">forwardInvocation:</code>方法，替换的实现是<code class="highlighter-rouge">__ASPECTS_ARE_BEING_CALLED__</code>，这个实现后面分析。如果原来的类实现了<code class="highlighter-rouge">forwardInvocation:</code>，用<code class="highlighter-rouge">AspectsForwardInvocationSelectorName</code>这个selector指向原来的实现。</p>
<h6 id="__aspects_are_being_called__">__ASPECTS_ARE_BEING_CALLED__</h6>
<p>接下来看一下<code class="highlighter-rouge">__ASPECTS_ARE_BEING_CALLED__</code>的实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define aspect_invoke(aspects, info) \
for (AspectIdentifier *aspect in aspects) {\
    [aspect invokeWithInfo:info];\
    if (aspect.options &amp; AspectOptionAutomaticRemoval) { \
        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
    } \
}
</span>
<span class="c1">// This is the swizzled forwardInvocation: method.
</span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__ASPECTS_ARE_BEING_CALLED__</span><span class="p">(</span><span class="n">__unsafe_unretained</span> <span class="n">NSObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">,</span> <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">invocation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">invocation</span><span class="p">);</span>
    <span class="n">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">;</span>
    <span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">aliasSelector</span><span class="p">;</span>
    <span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">objectContainer</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">);</span>
    <span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">classContainer</span> <span class="o">=</span> <span class="n">aspect_getContainerForClass</span><span class="p">(</span><span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">aliasSelector</span><span class="p">);</span>
    <span class="n">AspectInfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AspectInfo</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithInstance</span><span class="p">:</span><span class="n">self</span> <span class="nf">invocation</span><span class="p">:</span><span class="n">invocation</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">aspectsToRemove</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>

    <span class="c1">// Before hooks.
</span>    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">classContainer</span><span class="p">.</span><span class="n">beforeAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">beforeAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

    <span class="c1">// Instead hooks.
</span>    <span class="n">BOOL</span> <span class="n">respondsToAlias</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">.</span><span class="n">count</span> <span class="o">||</span> <span class="n">classContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">classContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
        <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="n">Class</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">invocation</span><span class="p">.</span><span class="n">target</span><span class="p">);</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">respondsToAlias</span> <span class="o">=</span> <span class="p">[</span><span class="n">klass</span> <span class="nf">instancesRespondToSelector</span><span class="p">:</span><span class="n">aliasSelector</span><span class="p">]))</span> <span class="p">{</span>
                <span class="p">[</span><span class="n">invocation</span> <span class="nf">invoke</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">respondsToAlias</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">klass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">klass</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="c1">// After hooks.
</span>    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">classContainer</span><span class="p">.</span><span class="n">afterAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">afterAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

    <span class="c1">// If no hooks are installed, call original implementation (usually to throw an exception)
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">respondsToAlias</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">originalSelector</span><span class="p">;</span>
        <span class="n">SEL</span> <span class="n">originalForwardInvocationSEL</span> <span class="o">=</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="n">AspectsForwardInvocationSelectorName</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="n">originalForwardInvocationSEL</span><span class="p">])</span> <span class="p">{</span>
            <span class="p">((</span><span class="kt">void</span><span class="p">(</span> <span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="n">NSInvocation</span> <span class="o">*</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">originalForwardInvocationSEL</span><span class="p">,</span> <span class="n">invocation</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">self</span> <span class="nf">doesNotRecognizeSelector</span><span class="p">:</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Remove any hooks that are queued for deregistration.
</span>    <span class="p">[</span><span class="n">aspectsToRemove</span> <span class="nf">makeObjectsPerformSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">remove</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div></div>
<p>前面把原来类<code class="highlighter-rouge">forwardInvocation:</code>的实现替换成<code class="highlighter-rouge">__ASPECTS_ARE_BEING_CALLED__</code>这个函数。所以当调用类hook方法时，会走到这个函数中。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">;</span>
<span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">);</span>
<span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">aliasSelector</span><span class="p">;</span>
<span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">objectContainer</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">);</span>
<span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">classContainer</span> <span class="o">=</span> <span class="n">aspect_getContainerForClass</span><span class="p">(</span><span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">aliasSelector</span><span class="p">);</span>
<span class="n">AspectInfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AspectInfo</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">initWithInstance</span><span class="p">:</span><span class="n">self</span> <span class="nf">invocation</span><span class="p">:</span><span class="n">invocation</span><span class="p">];</span>
</code></pre></div></div>
<p>这几行代码做了以下几件事：</p>
<ol>
  <li>获取原始的selector</li>
  <li>获取带有<code class="highlighter-rouge">aspects_</code>前缀的selector</li>
  <li>替换selector</li>
  <li>获取实例对象的aspectsContainer</li>
  <li>获取类的aspectContainer</li>
  <li>初始化<code class="highlighter-rouge">AspectInfo</code>，传入instance和invocation</li>
</ol>

<p>接下来调用<code class="highlighter-rouge">aspect_invoke</code>宏定义，执行需要再before调用的aspect。宏定义里面做了两件事，一个是执行了<code class="highlighter-rouge">[aspect invokeWithInfo:info]</code>方法，一个是把需要remove的aspect添加到等待移除的数组。</p>

<p>接下来看一下<code class="highlighter-rouge">[aspect invokeWithInfo:info]</code>的实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">invokeWithInfo</span><span class="p">:(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">info</span> <span class="p">{</span>
    <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">blockInvocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSInvocation</span> <span class="nf">invocationWithMethodSignature</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">blockSignature</span><span class="p">];</span>
    <span class="n">NSInvocation</span> <span class="o">*</span><span class="n">originalInvocation</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">originalInvocation</span><span class="p">;</span>
    <span class="n">NSUInteger</span> <span class="n">numberOfArguments</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">blockSignature</span><span class="p">.</span><span class="n">numberOfArguments</span><span class="p">;</span>

    <span class="c1">// paranoid: 偏执
</span>    <span class="c1">// Be extra paranoid. We already check that on hook registration.
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">numberOfArguments</span> <span class="o">&gt;</span> <span class="n">originalInvocation</span><span class="p">.</span><span class="n">methodSignature</span><span class="p">.</span><span class="n">numberOfArguments</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AspectLogError</span><span class="p">(</span><span class="s">@"Block has too many arguments. Not calling %@"</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 0: block
</span>    <span class="c1">// 1: 
</span>    <span class="c1">// The `self` of the block will be the AspectInfo. Optional.
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">numberOfArguments</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">blockInvocation</span> <span class="nf">setArgument</span><span class="p">:</span><span class="o">&amp;</span><span class="n">info</span> <span class="nf">atIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="c1">// 拷贝参数
</span>	<span class="kt">void</span> <span class="o">*</span><span class="n">argBuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">numberOfArguments</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="p">[</span><span class="n">originalInvocation</span><span class="p">.</span><span class="n">methodSignature</span> <span class="nf">getArgumentTypeAtIndex</span><span class="p">:</span><span class="n">idx</span><span class="p">];</span>
		<span class="n">NSUInteger</span> <span class="n">argSize</span><span class="p">;</span>
		<span class="n">NSGetSizeAndAlignment</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argSize</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">argBuf</span> <span class="o">=</span> <span class="n">reallocf</span><span class="p">(</span><span class="n">argBuf</span><span class="p">,</span> <span class="n">argSize</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">AspectLogError</span><span class="p">(</span><span class="s">@"Failed to allocate memory for block invocation."</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
		<span class="p">}</span>
        
		<span class="p">[</span><span class="n">originalInvocation</span> <span class="nf">getArgument</span><span class="p">:</span><span class="n">argBuf</span> <span class="nf">atIndex</span><span class="p">:</span><span class="n">idx</span><span class="p">];</span>
		<span class="p">[</span><span class="n">blockInvocation</span> <span class="nf">setArgument</span><span class="p">:</span><span class="n">argBuf</span> <span class="nf">atIndex</span><span class="p">:</span><span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="p">[</span><span class="n">blockInvocation</span> <span class="nf">invokeWithTarget</span><span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">block</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">argBuf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">argBuf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个方法中主要做了4件事：</p>
<ol>
  <li>根据<code class="highlighter-rouge">blockSignature</code>初始化<code class="highlighter-rouge">invocation</code></li>
  <li>把<code class="highlighter-rouge">info</code>放到参数的第二个位置</li>
  <li>把原来<code class="highlighter-rouge">invocation</code>中的参数拷贝到block的<code class="highlighter-rouge">invocation</code>中</li>
  <li>调用添加的aspect</li>
</ol>

<p>所以只要调用<code class="highlighter-rouge">aspect_invoke</code>就能调用我们添加的aspect。对应的传入beforeAspects<code class="highlighter-rouge">、</code>insteadAspects<code class="highlighter-rouge">、</code>afterAspects<code class="highlighter-rouge">就能实现</code>before<code class="highlighter-rouge">、</code>instead<code class="highlighter-rouge">、</code>after`的hook。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Instead hooks.
</span><span class="n">BOOL</span> <span class="n">respondsToAlias</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">.</span><span class="n">count</span> <span class="o">||</span> <span class="n">classContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">classContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="n">aspect_invoke</span><span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">insteadAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="n">Class</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">invocation</span><span class="p">.</span><span class="n">target</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">respondsToAlias</span> <span class="o">=</span> <span class="p">[</span><span class="n">klass</span> <span class="nf">instancesRespondToSelector</span><span class="p">:</span><span class="n">aliasSelector</span><span class="p">]))</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">invocation</span> <span class="nf">invoke</span><span class="p">];</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">respondsToAlias</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">klass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">klass</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果存在instead的aspect，直接调用，不存在的话，调用原来实现。这里需要注意，原来的实现绑定在<code class="highlighter-rouge">aliasSelector</code>上面。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// After hooks.
</span><span class="n">aspect_invoke</span><span class="p">(</span><span class="n">classContainer</span><span class="p">.</span><span class="n">afterAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
<span class="n">aspect_invoke</span><span class="p">(</span><span class="n">objectContainer</span><span class="p">.</span><span class="n">afterAspects</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</code></pre></div></div>
<p>这两行代码是调用After Aspect，原理和前面一样。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// If no hooks are installed, call original implementation (usually to throw an exception)
</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">respondsToAlias</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">originalSelector</span><span class="p">;</span>
    <span class="n">SEL</span> <span class="n">originalForwardInvocationSEL</span> <span class="o">=</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="n">AspectsForwardInvocationSelectorName</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="nf">respondsToSelector</span><span class="p">:</span><span class="n">originalForwardInvocationSEL</span><span class="p">])</span> <span class="p">{</span>
    <span class="p">((</span><span class="kt">void</span><span class="p">(</span> <span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span> <span class="n">SEL</span><span class="p">,</span> <span class="n">NSInvocation</span> <span class="o">*</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span> <span class="n">originalForwardInvocationSEL</span><span class="p">,</span> <span class="n">invocation</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">self</span> <span class="nf">doesNotRecognizeSelector</span><span class="p">:</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果原来的实现没有正确执行，调用原来的<code class="highlighter-rouge">forwardInvocation:</code>方法。如果原来的类没有实现<code class="highlighter-rouge">forwardInvocation:</code>方法，就会报错崩溃了。</p>

<h5 id="总结-1">总结</h5>
<p><code class="highlighter-rouge">aspect_hookClass</code>到这里就讲完了，这个方法的目的就是hook对应类的<code class="highlighter-rouge">forward Invocation:</code>方法。在里面进行了各种判断，下面总结一下判断的情况：</p>
<ol>
  <li>如果已经hook过了直接返回</li>
  <li>如果当前类是类对象，直接进行hook</li>
  <li>如果是KVO的情况，hook KVO产生的子类对象</li>
  <li>如果是对象，动态创建子类，hook子类的<code class="highlighter-rouge">forwardInvocation:</code>方法</li>
</ol>

<h4 id="给对应的方法添加aspect">给对应的方法添加Aspect</h4>
<p>通过<code class="highlighter-rouge">aspect_hookClass</code>方法对<code class="highlighter-rouge">forwardInvocation:</code>进行hook之后，会返回hook完后的类。接下来只需要把需要添加aspect的selector指向<code class="highlighter-rouge">forwardInvocation:</code>即可。下面看一下<code class="highlighter-rouge">Aspects</code>如何做的：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Method</span> <span class="n">targetMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
<span class="n">IMP</span> <span class="n">targetMethodIMP</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
</code></pre></div></div>
<p>这两句代码是获取要hook的方法原来的实现。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aspect_isMsgForwardIMP</span><span class="p">(</span><span class="n">targetMethodIMP</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// swizzling method
</span>    <span class="c1">// Make a method alias for the existing method implementation, it not already copied.
</span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeEncoding</span> <span class="o">=</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
    <span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">klass</span> <span class="nf">instancesRespondToSelector</span><span class="p">:</span><span class="n">aliasSelector</span><span class="p">])</span> <span class="p">{</span>
         <span class="n">__unused</span> <span class="n">BOOL</span> <span class="n">addedAlias</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">),</span> <span class="n">typeEncoding</span><span class="p">);</span>
         <span class="n">NSCAssert</span><span class="p">(</span><span class="n">addedAlias</span><span class="p">,</span> <span class="s">@"Original implementation for %@ is already copied to %@ on %@"</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">),</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">aliasSelector</span><span class="p">),</span> <span class="n">klass</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// We use forwardInvocation to hook in.
</span>    <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">aspect_getMsgForwardIMP</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">),</span> <span class="n">typeEncoding</span><span class="p">);</span>
    <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: Installed hook for -[%@ %@]."</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">BOOL</span> <span class="n">aspect_isMsgForwardIMP</span><span class="p">(</span><span class="n">IMP</span> <span class="n">impl</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">impl</span> <span class="o">==</span> <span class="n">_objc_msgForward</span>
<span class="cp">#if !defined(__arm64__)
</span>    <span class="o">||</span> <span class="n">impl</span> <span class="o">==</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span><span class="n">_objc_msgForward_stret</span>
<span class="cp">#endif
</span>    <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">aspect_isMsgForwardIMP</code>这个函数用来判断原来的实现是否指向<code class="highlighter-rouge">_objc_msgForward</code>或者<code class="highlighter-rouge">_objc_msgForward_stret</code>。这两个<code class="highlighter-rouge">IMP</code>是消息转发的标记。这里是判断当前的<code class="highlighter-rouge">IMP</code>是否为消息转发。</p>

<p>如果不是消息转发，就获取当前原始的selector对应<code class="highlighter-rouge">IMP</code>的方法编码，如果当前类不能响应<code class="highlighter-rouge">aspect_xxx</code>这个方法，就给当前类添加<code class="highlighter-rouge">aspect_xxx</code>selector，实现为原来方法的实现。</p>

<p>然后调用<code class="highlighter-rouge">class_replaceMethod</code>把原来的selector指向<code class="highlighter-rouge">_objc_msgForward</code>或者<code class="highlighter-rouge">_objc_msgForward_stret</code>。这样，当原来的方法被调用时，会直接走消息转发，因为前面已经hook了<code class="highlighter-rouge">forwardInvocation:</code>，所以会走到自己的处理逻辑中。</p>

<p>到这里，就完成了一次完整的hook。</p>

<h2 id="aspect_remove">aspect_remove</h2>
<p><code class="highlighter-rouge">aspect_remove</code>是移除一个hook。接下来看一下如何移除：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">BOOL</span> <span class="nf">aspect_remove</span><span class="p">(</span><span class="n">AspectIdentifier</span> <span class="o">*</span><span class="n">aspect</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCAssert</span><span class="p">([</span><span class="n">aspect</span> <span class="nf">isKindOfClass</span><span class="p">:</span><span class="n">AspectIdentifier</span><span class="p">.</span><span class="n">class</span><span class="p">],</span> <span class="s">@"Must have correct type."</span><span class="p">);</span>

    <span class="n">__block</span> <span class="n">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
    <span class="n">aspect_performLocked</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
        <span class="n">id</span> <span class="n">self</span> <span class="o">=</span> <span class="n">aspect</span><span class="p">.</span><span class="n">object</span><span class="p">;</span> <span class="c1">// strongify
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">aspectContainer</span> <span class="o">=</span> <span class="n">aspect_getContainerForObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aspect</span><span class="p">.</span><span class="n">selector</span><span class="p">);</span>
            <span class="n">success</span> <span class="o">=</span> <span class="p">[</span><span class="n">aspectContainer</span> <span class="nf">removeAspect</span><span class="p">:</span><span class="n">aspect</span><span class="p">];</span>

            <span class="n">aspect_cleanupHookedClassAndSelector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">aspect</span><span class="p">.</span><span class="n">selector</span><span class="p">);</span>
            <span class="c1">// destroy token
</span>            <span class="n">aspect</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="n">aspect</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
            <span class="n">aspect</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="n">NSString</span> <span class="o">*</span><span class="n">errrorDesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span><span class="s">@"Unable to deregister hook. Object already deallocated: %@"</span><span class="p">,</span> <span class="n">aspect</span><span class="p">];</span>
            <span class="n">AspectError</span><span class="p">(</span><span class="n">AspectErrorRemoveObjectAlreadyDeallocated</span><span class="p">,</span> <span class="n">errrorDesc</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">aspect_performLocked</code>是保证线程安全。先把aspect从aspectContainer中移除。然后调用<code class="highlighter-rouge">aspect_cleanupHookedClassAndSelector</code>取消对当前方法的hook。
接下来看一下<code class="highlighter-rouge">aspect_cleanupHookedClassAndSelector</code>的实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="n">isMetaClass</span> <span class="o">=</span> <span class="n">class_isMetaClass</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isMetaClass</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">klass</span> <span class="o">=</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这几句代码的作用是取到类对象。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Method</span> <span class="n">targetMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
<span class="n">IMP</span> <span class="n">targetMethodIMP</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">aspect_isMsgForwardIMP</span><span class="p">(</span><span class="n">targetMethodIMP</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Restore the original method implementation.
</span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeEncoding</span> <span class="o">=</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">targetMethod</span><span class="p">);</span>
    <span class="n">SEL</span> <span class="n">aliasSelector</span> <span class="o">=</span> <span class="n">aspect_aliasForSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">aliasSelector</span><span class="p">);</span>
    <span class="n">IMP</span> <span class="n">originalIMP</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">);</span>
    <span class="n">NSCAssert</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="s">@"Original implementation for %@ not found %@ on %@"</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">),</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">aliasSelector</span><span class="p">),</span> <span class="n">klass</span><span class="p">);</span>
    <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">originalIMP</span><span class="p">,</span> <span class="n">typeEncoding</span><span class="p">);</span>
     <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: Removed hook for -[%@ %@]."</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里检查当前的方法是否被标记成消息转发，如果标记成了消息转发，换回原来的方法实现。经过前面的代码，这些方法应该很容易看明白。这里有个问题需要注意，如果一个类的两个对象同时对类的某个方法进行hook，其中某个对象把方法还原后，另外一个对象的方法也还原了，这里是对整个类进行的操作。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aspect_deregisterTrackedSelector</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">aspect_deregisterTrackedSelector</span><span class="p">(</span><span class="n">id</span> <span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">selector</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">class_isMetaClass</span><span class="p">(</span><span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">)))</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">swizzledClassesDict</span> <span class="o">=</span> <span class="n">aspect_getSwizzledClassesDict</span><span class="p">();</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>
    <span class="n">Class</span> <span class="n">currentClass</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
    <span class="n">AspectTracker</span> <span class="o">*</span><span class="n">subclassTracker</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">AspectTracker</span> <span class="o">*</span><span class="n">tracker</span> <span class="o">=</span> <span class="n">swizzledClassesDict</span><span class="p">[</span><span class="nf">currentClass</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">subclassTracker</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">tracker</span> <span class="nf">removeSubclassTracker</span><span class="p">:</span><span class="n">subclassTracker</span> <span class="nf">hookingSelectorName</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">tracker</span><span class="p">.</span><span class="n">selectorNames</span> <span class="nf">removeObject</span><span class="p">:</span><span class="n">selectorName</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tracker</span><span class="p">.</span><span class="n">selectorNames</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tracker</span><span class="p">.</span><span class="n">selectorNamesToSubclassTrackers</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">[</span><span class="n">swizzledClassesDict</span> <span class="nf">removeObjectForKey</span><span class="p">:</span><span class="n">currentClass</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">subclassTracker</span> <span class="o">=</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="p">}</span><span class="k">while</span> <span class="p">((</span><span class="n">currentClass</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">currentClass</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">aspect_deregisterTrackedSelector</code>方法的作用是取消对该方法的tracker。继承体系中的tracker也取消。如果当前类没有进行过hook了，把当前类从<code class="highlighter-rouge">swizzledClassesDict</code>中移除。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get the aspect container and check if there are any hooks remaining. Clean up if there are not.
</span><span class="n">AspectsContainer</span> <span class="o">*</span><span class="n">container</span> <span class="o">=</span> <span class="n">aspect_getContainerForObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">container</span><span class="p">.</span><span class="n">hasAspects</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Destroy the container
</span>    <span class="n">aspect_destroyContainerForObject</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>

    <span class="c1">// Figure out how the class was modified to undo the changes.
</span>    <span class="n">NSString</span> <span class="o">*</span><span class="n">className</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">className</span> <span class="nf">hasSuffix</span><span class="p">:</span><span class="n">AspectsSubclassSuffix</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">Class</span> <span class="n">originalClass</span> <span class="o">=</span> <span class="n">NSClassFromString</span><span class="p">([</span><span class="n">className</span> <span class="nf">stringByReplacingOccurrencesOfString</span><span class="p">:</span><span class="n">AspectsSubclassSuffix</span> <span class="nf">withString</span><span class="p">:</span><span class="s">@""</span><span class="p">]);</span>
        <span class="n">NSCAssert</span><span class="p">(</span><span class="n">originalClass</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">,</span> <span class="s">@"Original class must exist"</span><span class="p">);</span>
        <span class="n">object_setClass</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">originalClass</span><span class="p">);</span>
        <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: %@ has been restored."</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">originalClass</span><span class="p">));</span>

        <span class="c1">// We can only dispose the class pair if we can ensure that no instances exist using our subclass.
</span>        <span class="c1">// Since we don't globally track this, we can't ensure this - but there's also not much overhead in keeping it around.
</span>        <span class="c1">//objc_disposeClassPair(object.class);
</span>    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Class is most likely swizzled in place. Undo that.
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">isMetaClass</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aspect_undoSwizzleClassInPlace</span><span class="p">((</span><span class="n">Class</span><span class="p">)</span><span class="n">self</span><span class="p">);</span>
         <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">class</span> <span class="o">!=</span> <span class="n">klass</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aspect_undoSwizzleClassInPlace</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
         <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果container中已经没有aspect了，移除当前类的关联对象。如果当前类里面包含<code class="highlighter-rouge">_Aspects_</code>后缀，说明创建了子类，需要把当前类的isa指针指回原来的类。</p>

<p><code class="highlighter-rouge">aspect_undoSwizzleClassInPlace</code>里面会调用<code class="highlighter-rouge">aspect_undoSwizzleForwardInvocation</code>，<code class="highlighter-rouge">aspect_undoSwizzleClassInPlace</code>里面只是进行了加锁，并且把当前class移除了<code class="highlighter-rouge">swizzledClasses</code>容器。接下来看一下<code class="highlighter-rouge">aspect_undoSwizzleForwardInvocation</code>实现：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">aspect_undoSwizzleForwardInvocation</span><span class="p">(</span><span class="n">Class</span> <span class="n">klass</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSCParameterAssert</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">NSSelectorFromString</span><span class="p">(</span><span class="n">AspectsForwardInvocationSelectorName</span><span class="p">));</span>
    <span class="n">Method</span> <span class="n">objectMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">NSObject</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">forwardInvocation</span><span class="o">:</span><span class="p">));</span>
    <span class="c1">// There is no class_removeMethod, so the best we can do is to retore the original implementation, or use a dummy.
</span>    <span class="n">IMP</span> <span class="n">originalImplementation</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span> <span class="p">?:</span> <span class="n">objectMethod</span><span class="p">);</span>
    <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">forwardInvocation</span><span class="o">:</span><span class="p">),</span> <span class="n">originalImplementation</span><span class="p">,</span> <span class="s">"v@:@"</span><span class="p">);</span>

    <span class="n">AspectLog</span><span class="p">(</span><span class="s">@"Aspects: %@ has been restored."</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">klass</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个方法的作用就是还原<code class="highlighter-rouge">forwardInvocation:</code>实现。</p>

<h2 id="aspects的坑">Aspects的坑</h2>
<p><code class="highlighter-rouge">Aspects</code>设计虽然很好，但是在项目里面用还是有一些坑的，比如我们在项目里面手动hook了一个方法，然后用<code class="highlighter-rouge">Aspects</code>也进行了hook，就有可能会崩溃(先用Aspects去hook，再手动hook就会崩溃)，比如下面代码：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">TestOne</span><span class="p">)</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">load</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">Class</span> <span class="n">class</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nf">class</span><span class="p">];</span>
        <span class="c1">// When swizzling a class method, use the following:
</span>        <span class="c1">// Class class = object_getClass((id)self);
</span>        <span class="n">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewWillAppear</span><span class="o">:</span><span class="p">);</span>
        <span class="n">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">xxx_viewWillAppear</span><span class="o">:</span><span class="p">);</span>
        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
        <span class="n">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span>
                                            <span class="n">originalSelector</span><span class="p">,</span>
                                            <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span>
                                            <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">class</span><span class="p">,</span>
                                <span class="n">swizzledSelector</span><span class="p">,</span>
                                <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span>
                                <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="cp">#pragma mark - Method Swizzling
</span><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">xxx_viewWillAppear</span><span class="o">:</span><span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="n">animated</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="nf">xxx_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@"viewWillAppear: %@"</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>
<p>先在一个分类中hook<code class="highlighter-rouge">viewWillAppear:</code>方法，然后在另一个分类中用<code class="highlighter-rouge">Aspects</code>也hook<code class="highlighter-rouge">viewWillAppear:</code>方法：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@implementation</span> <span class="nc">UIViewController</span> <span class="p">(</span><span class="nl">TestTwo</span><span class="p">)</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">load</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">UIViewController</span> <span class="nf">aspect_hookSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nf">viewWillAppear</span><span class="p">:)</span> <span class="n">withOptions</span><span class="o">:</span><span class="n">AspectPositionBefore</span> <span class="n">usingBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">AspectInfo</span><span class="o">&gt;</span> <span class="n">info</span> <span class="p">,</span> <span class="n">BOOL</span> <span class="n">animated</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSLog</span><span class="p">(</span><span class="s">@"viewWillAppear"</span><span class="p">);</span>
    <span class="p">}</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div></div>

<p>运行就会崩溃。即便能保证项目里面不手动hook，也不能保证一些第三方sdk不会手动进行hook。如果想要保证能正常使用，就需要对<code class="highlighter-rouge">Aspects</code>库进行改造。这个不在本文讨论范围，暂时不发散了。解决办法可以在参考链接中找到。</p>

<h2 id="参考链接">参考链接</h2>
<ul>
  <li><a href="https://halfrost.com/ios_aspect/gg">iOS 如何实现 Aspect Oriented Programming</a></li>
  <li><a href="http://wereadteam.github.io/2016/06/30/Aspects/">面向切面编程之 Aspects 源码解析及应用</a></li>
  <li><a href="http://www.jianshu.com/p/dc1deaa1b28e">Aspect和JSPatch各种兼容性问题</a></li>
  <li><a href="https://www.jianshu.com/p/17cf20a1c916">Aspects的hook冲突问题解决</a></li>
</ul>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
            
            
            <figure class="author-image">
                <a class="img" href="https://github.com/zhangdongpo"
                    style="background-image: url(/assets/images/freelf.jpg)"><span
                        class="hidden">Freelf's Picture</span></a>
            </figure>
            

            <section class="author">
                <h4><a href="/author/Freelf">Freelf</a></h4>

                
                <p> iOS Developer</p>
                
                <div class="author-meta">
                    <span class="author-location icon-location">
                        Beijing, China</span>
                    <span class="author-link icon-link"><a href="https://freelf.me"> freelf.me</a></span>
                </div>
            </section>

            <!-- /author  -->

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter"
                    href="http://twitter.com/share?text=Aspects源码分析&amp;url=Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook"
                    href="https://www.facebook.com/sharer/sharer.php?u=Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus"
                    href="https://plus.google.com/share?url=Aspects%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"
                    onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>
            
            

            <!-- Add Disqus Comments -->
            
            <div id="gitalk-container"></div>
<script src="/assets/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'b62d799fc3a6b1dd7de9',
        clientSecret: 'd5a315aa0855dd6a00cdb4025b88059c1b0c585f',
        repo: 'blog',
        owner: 'zhangdongpo',
        admin: 'zhangdongpo',
        id: md5(location.pathname), // Ensure uniqueness and length less than 50
        distractionFreeMode: false // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>
            

        </footer>

    </article>

</main>

<!-- /post -->

        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">面向自由编程</a> &copy; 2020</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', '', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/assets/js/index.js"></script>

</body>
</html>
