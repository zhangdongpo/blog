<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>freelf.me</title>
   
   <link></link>
   <description>Freelf's Blog</description>
   <language>en-uk</language>
   <managingEditor> Freelf</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>读《Design-Patterns-by-Tutorials》笔记——Builder Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Builder-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-10-09T15:45:52+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Builder-Pattern</guid>
	  <description><![CDATA[
	     <p>构造器模式允许一步一步的创建一个复杂的对象而不是一次创建完成。这个模式包括三个主要类型，UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1538746972.png" alt="构造器模式" /></p>

<!-- more -->

<ol>
  <li><strong>Director</strong>接收输入并且和 builder 协调。<strong>Director</strong>通常是一个 view controller或者是view controller 使用的帮助类。</li>
  <li><strong>Product</strong>是被创建的复杂对象，可以是一个class 或者 struct，取决于是否想要引用语义。通常是一个 model。</li>
  <li><strong>Builder</strong>接收一步步输入并且控制 product 的创建。经常是一个 class，可以通过引用被复用。</li>
</ol>

<h2 id="when-should-you-use-it">When should you use it?</h2>

<p>当我们想要使用一系列步骤创建一个复杂对象时可以使用构造器模式。当一个 product 需要几个部分输入时这个模式工作尤其优秀。构造器将如何创建product 的输入抽象并且以 director 想要提供输入的任何顺序接收他们。比如：我们可以使用这个模式去实现一个”汉堡构造器”。product 可能是一个<code class="highlighter-rouge">humburger</code>对象，它有一些输入，比如：肉，配料和胡椒酱。director 可能是一个<code class="highlighter-rouge">employee</code>对象，这个对象知道如何做汉堡，或者可能是一个 view controller，它可以接收用户的输入。
汉堡构造器可以以任意的顺序接收肉的选择，配料和胡椒酱并且根据需求创建一个汉堡。</p>

<h2 id="playground-example">Playground example</h2>

<p><strong>Builder</strong>是一个<strong>创造型模式</strong>。这是因为构造器模式是关于创造复杂产品的一个模式。这里我们将实现一个汉堡构造器的例子。
首先，我们先来创建一个<strong> product</strong>：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Product</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Hamburger</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">meat</span><span class="p">:</span> <span class="kt">Meat</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">sauce</span><span class="p">:</span> <span class="kt">Sauces</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">toppings</span><span class="p">:</span> <span class="kt">Toppings</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Hamburger</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">meat</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">+</span> <span class="s">" burger"</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Meat</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">beef</span>
  <span class="k">case</span> <span class="n">chicken</span>
  <span class="k">case</span> <span class="n">kitten</span>
  <span class="k">case</span> <span class="n">tofu</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Sauces</span><span class="p">:</span> <span class="kt">OptionSet</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">mayonnaise</span> <span class="o">=</span> <span class="kt">Sauces</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">mustard</span> <span class="o">=</span> <span class="kt">Sauces</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">ketchup</span> <span class="o">=</span> <span class="kt">Sauces</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">secret</span> <span class="o">=</span> <span class="kt">Sauces</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
  
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">=</span> <span class="n">rawValue</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Toppings</span><span class="p">:</span> <span class="kt">OptionSet</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">cheese</span> <span class="o">=</span> <span class="kt">Toppings</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">lettuce</span> <span class="o">=</span> <span class="kt">Toppings</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">pickles</span> <span class="o">=</span> <span class="kt">Toppings</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">tomatoes</span> <span class="o">=</span> <span class="kt">Toppings</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
  
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">=</span> <span class="n">rawValue</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>接下来，我们定义一个<strong>builder</strong></p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Builder</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">HamburgerBuilder</span> <span class="p">{</span>
  
  <span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">soldOut</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">meat</span><span class="p">:</span> <span class="kt">Meat</span> <span class="o">=</span> <span class="o">.</span><span class="n">beef</span>
  <span class="kd">public</span> <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">sauces</span><span class="p">:</span> <span class="kt">Sauces</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">public</span> <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">toppings</span><span class="p">:</span> <span class="kt">Toppings</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="kd">private</span> <span class="k">var</span> <span class="nv">soldOutMeats</span><span class="p">:</span> <span class="p">[</span><span class="kt">Meat</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="n">kitten</span><span class="p">]</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">addSauces</span><span class="p">(</span><span class="n">_</span> <span class="nv">sauce</span><span class="p">:</span> <span class="kt">Sauces</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sauces</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">sauce</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">removeSauces</span><span class="p">(</span><span class="n">_</span> <span class="nv">sauce</span><span class="p">:</span> <span class="kt">Sauces</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sauces</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">sauce</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">addToppings</span><span class="p">(</span><span class="n">_</span> <span class="nv">topping</span><span class="p">:</span> <span class="kt">Toppings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">toppings</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">topping</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">removeToppings</span><span class="p">(</span><span class="n">_</span> <span class="nv">topping</span><span class="p">:</span> <span class="kt">Toppings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">toppings</span><span class="o">.</span><span class="nf">remove</span><span class="p">(</span><span class="n">topping</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">setMeat</span><span class="p">(</span><span class="n">_</span> <span class="nv">meat</span><span class="p">:</span> <span class="kt">Meat</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="nf">isAvailable</span><span class="p">(</span><span class="n">meat</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">throw</span> <span class="kt">Error</span><span class="o">.</span><span class="n">soldOut</span> <span class="p">}</span>
    <span class="k">self</span><span class="o">.</span><span class="n">meat</span> <span class="o">=</span> <span class="n">meat</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">isAvailable</span><span class="p">(</span><span class="n">_</span> <span class="nv">meat</span><span class="p">:</span> <span class="kt">Meat</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">soldOutMeats</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">meat</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">build</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Hamburger</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Hamburger</span><span class="p">(</span><span class="nv">meat</span><span class="p">:</span> <span class="n">meat</span><span class="p">,</span>
                     <span class="nv">sauce</span><span class="p">:</span> <span class="n">sauces</span><span class="p">,</span>
                     <span class="nv">toppings</span><span class="p">:</span> <span class="n">toppings</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>接下来，我们添加<strong>director</strong>：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Director</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Employee</span> <span class="p">{</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">createCombo1</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Hamburger</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">builder</span> <span class="o">=</span> <span class="kt">HamburgerBuilder</span><span class="p">()</span>
    <span class="k">try</span> <span class="n">builder</span><span class="o">.</span><span class="nf">setMeat</span><span class="p">(</span><span class="o">.</span><span class="n">beef</span><span class="p">)</span>
    <span class="n">builder</span><span class="o">.</span><span class="nf">addSauces</span><span class="p">(</span><span class="o">.</span><span class="n">secret</span><span class="p">)</span>
    <span class="n">builder</span><span class="o">.</span><span class="nf">addToppings</span><span class="p">([</span><span class="o">.</span><span class="n">lettuce</span><span class="p">,</span> <span class="o">.</span><span class="n">tomatoes</span><span class="p">,</span> <span class="o">.</span><span class="n">pickles</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="nf">build</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">createKittenSpecial</span><span class="p">()</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Hamburger</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">builder</span> <span class="o">=</span> <span class="kt">HamburgerBuilder</span><span class="p">()</span>
    <span class="k">try</span> <span class="n">builder</span><span class="o">.</span><span class="nf">setMeat</span><span class="p">(</span><span class="o">.</span><span class="n">kitten</span><span class="p">)</span>
    <span class="n">builder</span><span class="o">.</span><span class="nf">addSauces</span><span class="p">(</span><span class="o">.</span><span class="n">mustard</span><span class="p">)</span>
    <span class="n">builder</span><span class="o">.</span><span class="nf">addToppings</span><span class="p">([</span><span class="o">.</span><span class="n">lettuce</span><span class="p">,</span> <span class="o">.</span><span class="n">tomatoes</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="nf">build</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>接下来测试一下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Example</span>
<span class="k">let</span> <span class="nv">burgerFlipper</span> <span class="o">=</span> <span class="kt">Employee</span><span class="p">()</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">combo1</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">burgerFlipper</span><span class="o">.</span><span class="nf">createCombo1</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Nom nom "</span> <span class="o">+</span> <span class="n">combo1</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">kittenBurger</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span>
  <span class="n">burgerFlipper</span><span class="o">.</span><span class="nf">createKittenSpecial</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Nom nom nom "</span> <span class="o">+</span> <span class="n">kittenBurger</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
  
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Sorry, no kitten burgers here... :["</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div>
<p>可以看到控制台打印：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Nom</span> <span class="n">nom</span> <span class="n">beef</span> <span class="n">burger</span>
<span class="kt">Sorry</span><span class="p">,</span> <span class="n">no</span> <span class="n">kitten</span> <span class="n">burgers</span> <span class="n">here</span><span class="o">...</span> <span class="p">:[</span>
</code></pre></div></div>

<h2 id="what-should-you-be-careful-about">What should you be careful about?</h2>

<p>构造器模式对需要多次输入创建复杂对象工作起来很好。如果你的 product 没有几个输入或者不能一步步被创建，构造器可能不适合，便利构造器可能更适合。</p>

<h2 id="tutorial-project">Tutorial project</h2>

<p>这里我们继续为以前的 app 增加功能，这节我们将使用构造器模式来添加创建新的<code class="highlighter-rouge">QuestionGroup</code>功能。实现效果如下：</p>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/Builder.gif" width="375px" /></p>

<p><a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Builder">Demo</a></p>
<h2 id="预告">预告</h2>
<p>下节我们讲学习 MVVM 设计模式，将会开启一个新的工程。这个工程就到此为止了。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design-Patterns-by-Tutorials》笔记——Observer Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Observer-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-10-04T21:44:56+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Observer-Pattern</guid>
	  <description><![CDATA[
	     <p>观察者模式让一个对象观察另一个对象的改变。在本章节，你将学习两种实现观察者模式的方法：</p>
<ol>
  <li>使用 KVO</li>
  <li>使用一个<code class="highlighter-rouge">Observable</code>包装。</li>
</ol>

<p>UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1538641129.png" alt="" /></p>

<!-- more -->

<p>这个模式包含两个主要对象：</p>
<ol>
  <li><strong>Subject</strong>是被观察对象。</li>
  <li><strong>Observer</strong>是观察对象。</li>
</ol>

<p>不幸的是，Swift 4现在没有语言层面的 KVO 支持。我们需要继承<code class="highlighter-rouge">Foundation</code>的<code class="highlighter-rouge">NSObject</code>,<code class="highlighter-rouge">NSObject</code>使用<code class="highlighter-rouge">Objective-C</code>runtime来实现 KVO。如果你不想或者不能继承<code class="highlighter-rouge">NSObject</code>,你可以自己封装一个<code class="highlighter-rouge">Observable</code>类来代替。
在本章，你将会使用 KVO 和<code class="highlighter-rouge">Observable</code>包装器来实现观察者模式。</p>

<h2 id="when-should-you-use-it">When should you use it?</h2>

<p>当你想要在另一个对象改变时收到改变消息时需要使用观察者模式。
这个模式经常在 MVC 中使用，view controller 是观察者，model 作为被观察者。这样 model 可以在改变时可以将改变传递回 view controller 而不需要知道 view controller 的类型。因此，不同的 view controller 可以观察共享 model 类型的变化。</p>

<h2 id="playground-example">Playground example</h2>

<p><strong>观察者模式</strong>是一种<strong>表现类型模式</strong>，这是因为<strong>观察者模式</strong>是关于一个对象观察另一个对象。
下面我们先用 KVO 来实现观察者模式，先添加一个<code class="highlighter-rouge">KVOUser</code>类：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>
<span class="c1">// MARK: - KVO</span>
<span class="c1">// 1</span>
<span class="kd">@objcMembers</span> <span class="kd">public</span> <span class="kd">class</span> <span class="kt">KVOUser</span><span class="p">:</span> <span class="kt">NSObject</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="kd">dynamic</span> <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="c1">// 3</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这段代码做了一下三件事情：</p>

<ol>
  <li><code class="highlighter-rouge">KVOUser</code>是一个<code class="highlighter-rouge">NSObject</code>子类，我们将要观察<code class="highlighter-rouge">KVOUser</code>。<code class="highlighter-rouge">@objcMembers</code>的作用和往没个属性前面加<code class="highlighter-rouge">@objc</code>的作用一样。在 Swift 4中，<code class="highlighter-rouge">NSObject</code>子类的属性没有自动暴露给<code class="highlighter-rouge">Objective-C</code>runtime。因为<code class="highlighter-rouge">NSObject</code>使用runtime 来实现 KVO。所以必须添加<code class="highlighter-rouge">@objcMembers</code>来让 KVO 工作。</li>
  <li><code class="highlighter-rouge">dynamic</code>的意思是这个属性使用<code class="highlighter-rouge">Objective-C</code>动态派发系统去调用<code class="highlighter-rouge">setter</code>和<code class="highlighter-rouge">getter</code>方法。这是为了让 KVO 工作，因为 KVO 交换了这个属性的 setter 方法来插入一些必要的逻辑。</li>
  <li>一个简单的构造器，设置了 name 的值。</li>
</ol>

<p>接下来，添加以下代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"---KVO Example---"</span><span class="p">)</span>
<span class="c1">// 2</span>
<span class="k">let</span> <span class="nv">kvoUser</span> <span class="o">=</span> <span class="kt">KVOUser</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Ray"</span><span class="p">)</span>
<span class="c1">// 3</span>
<span class="k">var</span> <span class="nv">kvoObserver</span><span class="p">:</span> <span class="kt">NSKeyValueObservation</span><span class="p">?</span> <span class="o">=</span> <span class="n">kvoUser</span><span class="o">.</span><span class="nf">observe</span><span class="p">(</span><span class="err">\</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">initial</span><span class="p">,</span> <span class="o">.</span><span class="k">new</span><span class="p">])</span> <span class="p">{</span> <span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">change</span><span class="p">)</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"User's name is </span><span class="se">\(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这段代码做了一下三件事情：</p>
<ol>
  <li>在控制台打印”— KVO Example”</li>
  <li>创建了一个 KVOUser 实例。</li>
  <li>声明了一个<code class="highlighter-rouge">NSKeyValueObservation?</code>实例，命名为<code class="highlighter-rouge">kvoObserver</code>。这就是<strong>观察者</strong>对象。我们可以通过调用<code class="highlighter-rouge">kvoUser.observe</code>方法获得它。</li>
</ol>

<p>这个方法自动返回一个非可选<code class="highlighter-rouge">NSKeyValueObservation</code>类型.然而，我们明确声明这个类型为可选是为了在后面可以设置这个变量为<code class="highlighter-rouge">nil</code>。
这个方法的第一个参数<code class="highlighter-rouge">keyPath</code>是观察的属性。我们可以通过使用<code class="highlighter-rouge">\.name</code>的简写形式来表达。根据上下文，Swift 会将其扩展为<code class="highlighter-rouge">\KVOUser.name</code>的完全 key path，来唯一标识<code class="highlighter-rouge">KVOUser</code>的 <code class="highlighter-rouge">name</code>。<code class="highlighter-rouge">options</code>是一个<code class="highlighter-rouge">NSKeyValueObservingOptions</code>的组合，这里我们具体说明我们想要收到<code class="highlighter-rouge">initial</code>和<code class="highlighter-rouge">new</code>的值。
最后一个参数是一个闭包，提供了<code class="highlighter-rouge">user</code>和<code class="highlighter-rouge">change</code>对象。<code class="highlighter-rouge">user</code>是改变后的 user。如果<code class="highlighter-rouge">.new</code>动作触发了闭包，<code class="highlighter-rouge">change</code>可能包含一个<code class="highlighter-rouge">oldValue</code>。这里，我们打印了当前<code class="highlighter-rouge">user</code>的<code class="highlighter-rouge">name</code>。
运行上面的代码可以看到在控制台打印了两行：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">---</span><span class="kt">KVO</span> <span class="kt">Example</span><span class="o">---</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Ray</span>
</code></pre></div></div>
<p>闭包在我们初始化 observer 时被调用了，因为我们指定了<code class="highlighter-rouge">.initial</code>。这意味着当初始化时发送观察结果。
接下来我们添加下面的代码来触发<code class="highlighter-rouge">.new</code>KVO 动作：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvoUser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"zdp"</span>
</code></pre></div></div>
<p>我们可以看到下面的打印：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="n">zdp</span>
</code></pre></div></div>
<p>最后我们添加下面的代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvoObserver</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="n">kvoUser</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Ray has left buliding"</span>
</code></pre></div></div>
<p>这里我们设置<code class="highlighter-rouge">kvoObserver</code>为 <code class="highlighter-rouge">nil</code>,我们可以观察到在设置<code class="highlighter-rouge">kvoObserver</code>为<code class="highlighter-rouge">nil</code>后，控制台不再打印信息。
Swift 4 KVO 的一个非常棒的特性就是我们不用明确 remove KVO 的 observer 或者闭包。代替的，observer 是一个 weak 引用，并且他们相关的闭包在 observer 变为 <code class="highlighter-rouge">nil</code> 时将自动移除。在Swift 以前版本和<code class="highlighter-rouge">Objective-C</code>中，你不得不明确调用<code class="highlighter-rouge">removeObserver(_:forKeyPath:)</code>,否则，在我们视图访问一个deallocated的 observer 时，app 将会 crash。
Swift 4 KVO 自动移除 observers 非常棒，但是这并不能弥补 KVO 最大的缺点，因为我们在使用 KVO 时必须继承<code class="highlighter-rouge">NSObject</code>并且使用<code class="highlighter-rouge">Objective-C</code>的 runtime。
如果你不想这样做，你可以创建一个自己的<code class="highlighter-rouge">Observable</code>包装来打破这种限制。
接下来，我们创建一个自己的<code class="highlighter-rouge">Observable</code>。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="k">Type</span><span class="o">&gt;</span> <span class="p">{</span>
    
    <span class="c1">// MARK: - CallBack</span>

    <span class="c1">// 2</span>
    <span class="kd">fileprivate</span> <span class="kd">class</span> <span class="kt">Callback</span> <span class="p">{</span>
        <span class="kd">fileprivate</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">?</span>
        <span class="kd">fileprivate</span> <span class="k">let</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">]</span>
        <span class="kd">fileprivate</span> <span class="k">let</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
        
        <span class="kd">fileprivate</span> <span class="nf">init</span><span class="p">(</span><span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">,</span>
                         <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">],</span>
                         <span class="nv">closure</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">observer</span>
            <span class="k">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
            <span class="k">self</span><span class="o">.</span><span class="n">closure</span> <span class="o">=</span> <span class="n">closure</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// MARK: - ObservableOptions</span>

<span class="c1">// 3</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ObservableOptions</span><span class="p">:</span> <span class="kt">OptionSet</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">initial</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">old</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">new</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
    
    
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">=</span> <span class="n">rawValue</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面代码做了3件事：</p>
<ol>
  <li>声明了一个<code class="highlighter-rouge">Observable&lt;Type&gt;</code>的泛型类。</li>
  <li>声明了一个内置的，<code class="highlighter-rouge">fileprivate</code>的类，叫做<code class="highlighter-rouge">Callback</code>。我们使用他来关联 <code class="highlighter-rouge">observer</code>,<code class="highlighter-rouge">options</code>和<code class="highlighter-rouge">closure</code>。注意，<code class="highlighter-rouge">observer</code>是一个 <code class="highlighter-rouge">weak</code>属性，所以需要是一个类。因此我们用<code class="highlighter-rouge">AnyObject</code>类型来表示它。最后，你将看到如何在 observer 变为 <code class="highlighter-rouge">nil</code>后去自动移除观察observer。</li>
  <li>接下来，我们声明了一个<code class="highlighter-rouge">ObservableOptions</code>,它和 KVO 的<code class="highlighter-rouge">NSKeyValueObservingOptions</code>非常相似。因为 Swift 现在不允许内置 <code class="highlighter-rouge">OptionsSets</code>。所以，我们在<code class="highlighter-rouge">Observable&lt;Type&gt;</code>的外面声明它。</li>
</ol>

<p>接下来，我们继续给<code class="highlighter-rouge">Observable&lt;Type&gt;</code>添加代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Properties</span>
<span class="kd">public</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="k">Type</span>
<span class="c1">// MARK: - Object Lifecycle</span>
<span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们声明了一个 value 属性和初始化方法。接下来，我们添加操作 observers 的方法：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// MARK: - Managing Observers</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">callbacks</span><span class="p">:</span> <span class="p">[</span><span class="kt">Callback</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">addObserver</span><span class="p">(</span>
        <span class="n">_</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">,</span>
        <span class="nv">removeIfExists</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="k">new</span><span class="p">],</span>
        <span class="nv">closure</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">removeIfExists</span> <span class="p">{</span>
            <span class="nf">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="nv">callback</span> <span class="o">=</span> <span class="kt">Callback</span><span class="p">(</span><span class="nv">observer</span><span class="p">:</span> <span class="n">observer</span><span class="p">,</span>
                                <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">,</span>
                                <span class="nv">closure</span><span class="p">:</span> <span class="n">closure</span><span class="p">)</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="o">.</span><span class="n">initial</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">closure</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">.</span><span class="n">initial</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">removeObserver</span><span class="p">(</span><span class="n">_</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">observer</span> <span class="o">!==</span> <span class="n">observer</span>
        <span class="p">}</span>
    <span class="p">}</span>

	<span class="kd">private</span> <span class="kd">func</span> <span class="nf">removeNilObserverCallbacks</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="k">Type</span><span class="p">,</span>
                                 <span class="nv">option</span><span class="p">:</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">callbacksToNotify</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">callbacksToNotify</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="nf">closure</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>我们需要在改变属性时通知 observer，所以我们需要在 <code class="highlighter-rouge">value</code>改变时去做一些事情：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">public</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="k">Type</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="nf">removeNilObserverCallbacks</span><span class="p">()</span>
            <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">oldValue</span><span class="p">,</span> <span class="nv">option</span><span class="p">:</span> <span class="o">.</span><span class="n">old</span><span class="p">)</span>
            <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">option</span><span class="p">:</span> <span class="o">.</span><span class="k">new</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

</code></pre></div></div>
<p>这里，我们在<code class="highlighter-rouge">value</code>的<code class="highlighter-rouge">didSet</code>方法中，添加了一些代码。到这里，我们的<code class="highlighter-rouge">Observable&lt;Type&gt;</code>已经封装完了，整体代码如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">import</span> <span class="kt">Foundation</span>
<span class="c1">// 1</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="k">Type</span><span class="o">&gt;</span> <span class="p">{</span>
    
    <span class="c1">// MARK: - CallBack</span>
    <span class="kd">fileprivate</span> <span class="kd">class</span> <span class="kt">Callback</span> <span class="p">{</span>
        <span class="kd">fileprivate</span> <span class="k">weak</span> <span class="k">var</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">?</span>
        <span class="kd">fileprivate</span> <span class="k">let</span> <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">]</span>
        <span class="kd">fileprivate</span> <span class="k">let</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
        
        <span class="kd">fileprivate</span> <span class="nf">init</span><span class="p">(</span><span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">,</span>
                         <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">],</span>
                         <span class="nv">closure</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">observer</span>
            <span class="k">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
            <span class="k">self</span><span class="o">.</span><span class="n">closure</span> <span class="o">=</span> <span class="n">closure</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Properties</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="k">Type</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="nf">removeNilObserverCallbacks</span><span class="p">()</span>
            <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">oldValue</span><span class="p">,</span> <span class="nv">option</span><span class="p">:</span> <span class="o">.</span><span class="n">old</span><span class="p">)</span>
            <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span> <span class="nv">option</span><span class="p">:</span> <span class="o">.</span><span class="k">new</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Object Lifecycle</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="p">}</span>
    
    <span class="c1">// MARK: - Managing Observers</span>
    
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">callbacks</span><span class="p">:</span> <span class="p">[</span><span class="kt">Callback</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">addObserver</span><span class="p">(</span>
        <span class="n">_</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">,</span>
        <span class="nv">removeIfExists</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="kt">ObservableOptions</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="k">new</span><span class="p">],</span>
        <span class="nv">closure</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="k">Type</span><span class="p">,</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">removeIfExists</span> <span class="p">{</span>
            <span class="nf">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="nv">callback</span> <span class="o">=</span> <span class="kt">Callback</span><span class="p">(</span><span class="nv">observer</span><span class="p">:</span> <span class="n">observer</span><span class="p">,</span>
                                <span class="nv">options</span><span class="p">:</span> <span class="n">options</span><span class="p">,</span>
                                <span class="nv">closure</span><span class="p">:</span> <span class="n">closure</span><span class="p">)</span>
        <span class="n">callbacks</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="o">.</span><span class="n">initial</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">closure</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">.</span><span class="n">initial</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">removeObserver</span><span class="p">(</span><span class="n">_</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">observer</span> <span class="o">!==</span> <span class="n">observer</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">removeNilObserverCallbacks</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">callbacks</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">observer</span> <span class="o">!=</span> <span class="kc">nil</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">notifyCallbacks</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="k">Type</span><span class="p">,</span>
                                 <span class="nv">option</span><span class="p">:</span> <span class="kt">ObservableOptions</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">callbacksToNotify</span> <span class="o">=</span> <span class="n">callbacks</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">callbacksToNotify</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span>
            <span class="nv">$0</span><span class="o">.</span><span class="nf">closure</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - ObservableOptions</span>

<span class="c1">// 3</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">ObservableOptions</span><span class="p">:</span> <span class="kt">OptionSet</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">initial</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">old</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">new</span> <span class="o">=</span> <span class="kt">ObservableOptions</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
    
    
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">rawValue</span> <span class="o">=</span> <span class="n">rawValue</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>接下来，我们测试一下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//MARK: - Observable Example</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kt">Observable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Observer</span> <span class="p">{</span> <span class="p">}</span>
<span class="nf">print</span><span class="p">(</span><span class="s">""</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"--- Observable Example ---"</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">User</code>是一个<strong>Subject</strong>,它有一个<code class="highlighter-rouge">name</code>属性，我们将观察这个属性。<code class="highlighter-rouge">Observer</code>是一个观察者<strong> observer</strong>，这可以是一个<code class="highlighter-rouge">NSObject</code>实例或者任意的类。
到这里，控制台只打印了以下内容：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">---</span> <span class="kt">Observable</span> <span class="kt">Example</span> <span class="o">---</span>
</code></pre></div></div>
<p>我们接下来添加以下代码测试：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="kt">User</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Madeline"</span><span class="p">)</span>

<span class="k">var</span> <span class="nv">observer</span><span class="p">:</span> <span class="kt">Observer</span><span class="p">?</span> <span class="o">=</span> <span class="kt">Observer</span><span class="p">()</span>

<span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nf">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="o">!</span><span class="p">,</span>
                      <span class="nv">options</span><span class="p">:</span> <span class="p">[</span><span class="o">.</span><span class="n">initial</span><span class="p">,</span> <span class="o">.</span><span class="k">new</span><span class="p">])</span> <span class="p">{</span>
                        <span class="n">name</span> <span class="p">,</span> <span class="n">change</span> <span class="k">in</span>
                        <span class="nf">print</span><span class="p">(</span><span class="s">"User's name is </span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    
<span class="p">}</span>
</code></pre></div></div>
<p>运行到这里，可以看到控制台打印内容如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">---</span> <span class="kt">Observable</span> <span class="kt">Example</span> <span class="o">---</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Madeline</span>
</code></pre></div></div>
<p>接下来，添加以下代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">"Amelia"</span>
</code></pre></div></div>
<p>控制台打印如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">---</span> <span class="kt">Observable</span> <span class="kt">Example</span> <span class="o">---</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Madeline</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Amelia</span>
</code></pre></div></div>
<p>接下来测试吧 observer 置为<code class="highlighter-rouge">nil</code>,看下会不会自动移除。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">observer</span> <span class="o">=</span> <span class="kc">nil</span>

<span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">"Amelia is outta here!"</span>
</code></pre></div></div>
<p>控制台内容如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">---</span> <span class="kt">Observable</span> <span class="kt">Example</span> <span class="o">---</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Madeline</span>
<span class="kt">User</span><span class="err">'</span><span class="n">s</span> <span class="n">name</span> <span class="k">is</span> <span class="kt">Amelia</span>
</code></pre></div></div>
<p>通过内容，我们可以看到，我们把 observer 置为 <code class="highlighter-rouge">nil</code>后，再改变 value，我们将观察不到任何信息。</p>

<h2 id="what-should-you-be-careful-about">What should you be careful about?</h2>

<p>对简单的 models 或者一些从来不会改变的属性使用观察者模式是一种过分的行为，这可能会导致一些不必要的工作。
在我们实施观察者模式之前，我们需要确定我们希望改变什么以及在什么条件下改变。如果我们不能确定对象或者属性发生改变的原因，我们最好不要立马实施 KVO/Observable。
作为一个特殊标识，如果一个属性从来不会改变，就不要去把它做为一个 observable 的属性。</p>

<h2 id="tutorial-project">Tutorial project</h2>

<p>这里我们会继续给以前的 app 增加功能。我们将使用这个模式在”Seletct Question Group”页面展示用户最新的分数。并且可以保存分数，当我们杀掉 app 后再次进来还会显示分数。在这个例子中，我们将使用<code class="highlighter-rouge">Observable</code>来代替 KVO。实现效果如下：</p>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2018100422338.gif" width="375px" /></p>

<p><a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Observer">Demo</a></p>
<h2 id="预告">预告</h2>
<p>下节我们将学习 Builder Pattern。下节，我们将会使用 Builder Pattern 给 app 增加让用户自己创建问题组的功能。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design-Patterns-by-Tutorials》笔记——Memento Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Memento-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-10-03T11:15:11+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Memento-Pattern</guid>
	  <description><![CDATA[
	     <p>备忘录模式允许一个对象可以被保存和恢复。包括三个部分。</p>
<ol>
  <li><strong>Originator</strong>: 需要被保存和恢复的对象。</li>
  <li><strong>Memento</strong>: 代表保存的状态。</li>
  <li><strong> Caretaker</strong>: 从 originator 请求保存，并且接收一个 memento 作为响应。caretaker 负责保管这些 memento，并在稍后向 originator 提供这些 memento来恢复 originator 的状态。
虽然不是严格要求，iOS通常使用<code class="highlighter-rouge">Encoder</code>来讲 originator 的状态保存到 memento，并且使用<code class="highlighter-rouge">Decoder</code>把 memento 恢复到 originator。这使编码和解码的逻辑可以通用。比如：<code class="highlighter-rouge">JSONEncoder</code>和<code class="highlighter-rouge">JSONDecoder</code>允许一个对象可以编码为 <code class="highlighter-rouge">JSON</code> 数据，也可以从<code class="highlighter-rouge">JSON</code>数据中解码。
UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1538272701.png" alt="" /></li>
</ol>

<!-- more -->

<h2 id="when-should-you-use-it">When should you use it?</h2>

<p>当我们想要保存并且以后需要恢复一个对象的状态时需要用到备忘录模式。
比如：我们可以使用这个模式来实现一个游戏系统，originator 就是游戏的状态(比如：等级，健康状态，生命值等等)，memento 就是保存的数据，caretaker 就是游戏系统。
我们可以持续保存一系列数据，表示一个以前的存档。我们也可以用这个模式在 IDEs或者图表软件中实现一些 undo/redo 的特性。</p>

<h2 id="playground-example">Playground example</h2>

<p><strong>备忘录模式</strong>是<strong>表现模式</strong>得一种。这是因为这个模式是和保存和恢复表现相关的模式。我们在这个例子中创建一个简单的游戏系统。
首先我们需要定义一个 <strong>originator</strong>，用以下代码来创建：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">Foundation</span>

<span class="c1">// MARK: - Originator</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Game</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
  
  <span class="kd">public</span> <span class="kd">class</span> <span class="kt">State</span><span class="p">:</span> <span class="kt">Codable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">attemptsRemaining</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">level</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">score</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">state</span> <span class="o">=</span> <span class="kt">State</span><span class="p">()</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">rackUpMassivePoints</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">state</span><span class="o">.</span><span class="n">score</span> <span class="o">+=</span> <span class="mi">9002</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">monstersEatPlayer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">state</span><span class="o">.</span><span class="n">attemptsRemaining</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里，你定义了一个<code class="highlighter-rouge">Game</code>类，它有一个内部<code class="highlighter-rouge">State</code>保存 game 属性，并且它有操作游戏内动作的方法。我们还要声明<code class="highlighter-rouge">Game</code>和<code class="highlighter-rouge">State</code>遵守<code class="highlighter-rouge">Codable</code>协议。
什么是<code class="highlighter-rouge">Codable</code>? Apple 在 Swift 4中引进了<code class="highlighter-rouge">Codable</code>。任何类型都可以遵守<code class="highlighter-rouge">Codable</code>,用 Apple 的话来说就是：转换本身的外部代表。本质上，就是一个可以存储和恢复其自己的类型。听起来很类似？是的，这的确就是我们想让 originator 拥有的能力。
因为<code class="highlighter-rouge">Game</code>和<code class="highlighter-rouge">State</code>的所有属性都遵守了<code class="highlighter-rouge">Codable</code>协议，编译器会自动生成<code class="highlighter-rouge">Codable</code>协议所必须实现的方法。<code class="highlighter-rouge">String</code>,<code class="highlighter-rouge">Int</code>,<code class="highlighter-rouge">Double</code>和大多数<code class="highlighter-rouge">Swift</code>提供的类型都遵守了<code class="highlighter-rouge">Codable</code>协议。
<code class="highlighter-rouge">Codable</code>是一个<code class="highlighter-rouge">typealias</code>,结合了<code class="highlighter-rouge">Encodable</code>和<code class="highlighter-rouge">Decodable</code>协议：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">Codable</span> <span class="o">=</span> <span class="kt">Decodable</span> <span class="o">&amp;</span> <span class="kt">Encodable</span>
</code></pre></div></div>
<p>可编码类型可以通过<code class="highlighter-rouge">Encoder</code>编码为外部表示。外部表示的实际类型取决于你所使用的<code class="highlighter-rouge">Encoder</code>。<code class="highlighter-rouge">Foundation</code>提供了几种默认的编码器，比如<code class="highlighter-rouge">J SONEncoder</code>是为了把对象转化为 JSON 数据。
可以通过<code class="highlighter-rouge">Decoder</code>把外部表现转化为可解码类型。<code class="highlighter-rouge">Foundation</code>也提供了解码器。比如<code class="highlighter-rouge">JSONDecoder</code>可以把 JSON 数据转化为对象。
接下来我们需要一个<strong>memento</strong>，在上面的代码下面添加如下代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Memento</span>
<span class="kd">typealias</span> <span class="kt">GameMemento</span> <span class="o">=</span> <span class="kt">Data</span>
</code></pre></div></div>
<p>理论上，我们一点也不需要这样声明。这里就是说明你<code class="highlighter-rouge">GameMemento</code>实际上是<code class="highlighter-rouge">Data</code>。这将是<code class="highlighter-rouge">Encoder</code>存储的数据，并且是<code class="highlighter-rouge">Decoder</code>恢复的元数据。
接下来，我们需要添加一个<strong>caretaker</strong>,添加如下代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - CareTaker</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">GameSystem</span> <span class="p">{</span>
  
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">decoder</span> <span class="o">=</span> <span class="kt">JSONDecoder</span><span class="p">()</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">encoder</span> <span class="o">=</span> <span class="kt">JSONEncoder</span><span class="p">()</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">userDefaults</span> <span class="o">=</span> <span class="kt">UserDefaults</span><span class="o">.</span><span class="n">standard</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="n">_</span> <span class="nv">game</span><span class="p">:</span> <span class="kt">Game</span><span class="p">,</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="n">encoder</span><span class="o">.</span><span class="nf">encode</span><span class="p">(</span><span class="n">game</span><span class="p">)</span>
    <span class="n">userDefaults</span><span class="o">.</span><span class="nf">set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="n">title</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">func</span> <span class="nf">load</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Game</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="n">userDefaults</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="n">title</span><span class="p">),</span>
      <span class="k">let</span> <span class="nv">game</span> <span class="o">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">Game</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">Error</span><span class="o">.</span><span class="n">gameNotFound</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">game</span>
  <span class="p">}</span>
  
  <span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">gameNotFound</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们先来模拟一下游戏过程：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Example</span>
<span class="k">var</span> <span class="nv">game</span> <span class="o">=</span> <span class="kt">Game</span><span class="p">()</span>
<span class="n">game</span><span class="o">.</span><span class="nf">monstersEatPlayer</span><span class="p">()</span>
<span class="n">game</span><span class="o">.</span><span class="nf">rackUpMassivePoints</span><span class="p">()</span>
</code></pre></div></div>
<p>然后存储一下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Save Game</span>
<span class="k">let</span> <span class="nv">gameSystem</span> <span class="o">=</span> <span class="kt">GameSystem</span><span class="p">()</span>
<span class="k">try</span> <span class="n">gameSystem</span><span class="o">.</span><span class="nf">save</span><span class="p">(</span><span class="n">game</span><span class="p">,</span> <span class="nv">title</span><span class="p">:</span> <span class="s">"Best Game Ever"</span><span class="p">)</span>
</code></pre></div></div>
<p>然后读取一下记录：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Load Game</span>
<span class="n">game</span> <span class="o">=</span> <span class="k">try!</span> <span class="n">gameSystem</span><span class="o">.</span><span class="nf">load</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Best Game Ever"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Loaded Game Score: </span><span class="se">\(</span><span class="n">game</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">score</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>
<p>Emmm,是不是很不错！</p>

<h2 id="what-should-you-be-careful-about">What should you be careful about?</h2>

<p>当添加和移除<code class="highlighter-rouge">Codable</code>属性时需要当心，编码和解码都是可以抛出错误的。如果我们使用<code class="highlighter-rouge">try!</code>强制解包，并且丢失了必要的数据，app 会 crash。
为了规避这种问题，除非你确定操作可以成功，应该尽量避免使用<code class="highlighter-rouge">try!</code>。当改变模型时也需要提前规划。比如：我们可以给模型添加版本号或者使用带版本号的数据库。然而我们需要考虑入魂儿处理版本升级。我们可以选择当我们有一个新的版本时删掉旧的数据，或者创建一个升级路径把旧的数据转化为新的数据，或者使用这两种方法的结合。</p>

<h2 id="tutorial-project">Tutorial project</h2>

<p>下面我们继续给我们以前的 app 增加功能。我们将使用备忘录模式添加一个 app 重要的特性：保存<code class="highlighter-rouge">QuestionGroup</code>分数的能力。
实现效果：</p>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2018-10-03%2010.57.41.gif" width="375px" /></p>

<p>再次运行会在控制台打印：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Hiragana</span><span class="p">:</span> <span class="n">correctCount</span> <span class="mi">5</span><span class="p">,</span> <span class="n">incorrectCount</span> <span class="mi">6</span>
<span class="kt">Katakana</span><span class="p">:</span> <span class="n">correctCount</span> <span class="mi">5</span><span class="p">,</span> <span class="n">incorrectCount</span> <span class="mi">5</span>
<span class="kt">Basic</span> <span class="kt">Phrases</span><span class="p">:</span> <span class="n">correctCount</span> <span class="mi">0</span><span class="p">,</span> <span class="n">incorrectCount</span> <span class="mi">0</span>
<span class="kt">Numbers</span><span class="p">:</span> <span class="n">correctCount</span> <span class="mi">0</span><span class="p">,</span> <span class="n">incorrectCount</span> <span class="mi">0</span>
</code></pre></div></div>
<p><a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Memento">Demo</a></p>

<h2 id="预告">预告</h2>

<p>下节我们将学习观察者模式。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design-Patterns-by-Tutorials》笔记——Singleton Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Singleton-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-09-28T12:27:27+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Singleton-Pattern</guid>
	  <description><![CDATA[
	     <p>单例模式限制一个类仅仅有一个实例。每个这个类的引用都指向同一个实例。在 iOS 开发中非常常见这种模式，因为 Apple 广泛使用单例模式。
UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1538101105.png" alt="" />
“singleton plus”模式也很常用，这个模式提供了一个共享单例，但是也允许其他实例被创建。</p>

<!-- more -->

<h2 id="when-should-you-use-it">When should you use it?</h2>

<p>如果一个类有多个实例会导致问题或者不符合逻辑时使用单例模式。
如果在大部分时间共享实例有用，但是你也想要创建一个自定义实例时使用 sigleton plus 模式。<code class="highlighter-rouge">FileManager</code>就是一个例子。他有一个<code class="highlighter-rouge">default</code>实例，这是一个单例，但是你也可以自己创建一个。如果你再后台线程使用它，通常需要创建一个自己的。</p>

<h2 id="playground-example">Playground example</h2>

<p><strong>单例模式</strong>是<strong>创建模式</strong>的一种。因为单例是关于创建一个共享实例。
单例和 singleton plus 在 Apple 的框架中很普遍。
比如：<code class="highlighter-rouge">UIApplication</code>是一个纯单例。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="c1">// MARK: - Singleton</span>
<span class="k">let</span> <span class="nv">app</span> <span class="o">=</span> <span class="kt">UIApplication</span><span class="o">.</span><span class="n">shared</span>
<span class="c1">// let app2 = UIApplication()</span>
</code></pre></div></div>
<p>如果你把 app2 解注，会编译错误。<code class="highlighter-rouge">UIApplication</code>不允许创建其他实例。
你也可以创建自己的单例类，比如以下代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">MySingleton</span> <span class="p">{</span>
  <span class="c1">// 1</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span> <span class="o">=</span> <span class="kt">MySingleton</span><span class="p">()</span>
  <span class="c1">// 2</span>
  <span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 3</span>
<span class="k">let</span> <span class="nv">mySingleton</span> <span class="o">=</span> <span class="kt">MySingleton</span><span class="o">.</span><span class="n">shared</span>
<span class="c1">// 4</span>
<span class="c1">// let mySingleton2 = MySingleton()</span>
</code></pre></div></div>
<ol>
  <li>首先声明一个 <code class="highlighter-rouge">public static</code> 属性，叫做<code class="highlighter-rouge">shared</code>,这是一个单例实例。</li>
  <li>把<code class="highlighter-rouge">init</code>方法私有化，不允许创建其他的实例。</li>
  <li>使用<code class="highlighter-rouge">MySingleton.shared</code>获取单例。</li>
  <li>如果你创建额外的实例将会导致编译错误。</li>
</ol>

<p>singleton plus 例子如下：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Singleton Plus</span>
<span class="k">let</span> <span class="nv">defaultFileManager</span> <span class="o">=</span> <span class="kt">FileManager</span><span class="o">.</span><span class="k">default</span>
<span class="k">let</span> <span class="nv">customFileManager</span> <span class="o">=</span> <span class="kt">FileManager</span><span class="p">()</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">FileManager</code>提供了<code class="highlighter-rouge">default</code>单例。
我们可以创建一个新的实例，并不会导致编译错误。这说明<code class="highlighter-rouge">FileManager</code>提供了 singleton plus 模式。
我们可以很简单的创建自己的 singleton plus 模式类，比如下面代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">SingletonPlus</span> <span class="p">{</span>
  <span class="c1">// 1</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span> <span class="o">=</span> <span class="kt">SingletonPlus</span><span class="p">()</span>
  <span class="c1">// 2</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 3</span>
<span class="k">let</span> <span class="nv">singletonPlus</span> <span class="o">=</span> <span class="kt">SingletonPlus</span><span class="o">.</span><span class="n">shared</span>
<span class="c1">// 4</span>
<span class="k">let</span> <span class="nv">singletonPlus2</span> <span class="o">=</span> <span class="kt">SingletonPlus</span><span class="p">()</span>
</code></pre></div></div>
<ol>
  <li>我们声明一个<code class="highlighter-rouge">shared</code>属性，就像单例模式一样。有时这个属性也叫做<code class="highlighter-rouge">default</code>。</li>
  <li>不想纯单例，我们把<code class="highlighter-rouge">init</code>方法声明为<code class="highlighter-rouge">public</code>,允许创建额外的实例。</li>
  <li>可以通过<code class="highlighter-rouge">MySingletonPlus.shared</code>获取单例。</li>
  <li>也可以创建一个新的实例。</li>
</ol>

<h2 id="what-should-you-be-careful-about">What should you be careful about?</h2>

<p>单例模式非常容易滥用。
如果你某个地方想用单例，首先考虑下其他方式完成任务。
比如：如果你仅仅从一个 view controller 传递消息到另一个 view controller，单例不适合。可以通过一个初始化函数或者属性传递。
如果你确定你确实需要单例，考虑下是否 singleton plus 更有用。
是否多个实例会导致问题？是否自定义实例会有用处？这两个问题的答案将会决定到底使用纯单例还是 singleton plus。
单例通常会为测试带来麻烦。如果你将状态存在全局对象中，比如单例。那么测试的顺序可能很重要。模仿这些顺序很痛苦。这就是导致测试很痛苦的原因。
如果你经常需要一些自定义实例，那么使用普通对象最好。</p>
<h2 id="tutorial-project">Tutorial project</h2>

<p>接下在我们继续以前的工程。
上一章我们在使用策略时采用了硬编码的方式。用户不能手动改变策略。这节的任务就是可以让用户自己选择问题展示的方式。可以切换顺序展示还是随机展示。
首先我们需要有一个地方去存储 app 的设置。你需要创建一个单例来实现这个。
实现效果如下：</p>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2018-09-28%2012.06.40.gif" width="375px" /></p>

<p><a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Singleton">Demo</a></p>

<h2 id="预告">预告</h2>

<p>下节将介绍备忘录模式。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design Patterns by Tutorials》笔记——Strategy Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Strategy-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-09-27T19:32:17+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Strategy-Pattern</guid>
	  <description><![CDATA[
	     <p>策略模式定义了一系列可交换的对象，这些对象可以在运行时设置或者切换。这个模式有三部分。</p>
<ul>
  <li><strong>使用策略的对象</strong>：在 iOS 开发中这个对象通常是一个<code class="highlighter-rouge">UIViewController</code>，但是理论上可以是任何需要交换表现的对象。</li>
  <li><strong>策略协议</strong>：定义了每个策略必须实现的方法。</li>
  <li><strong>策略对象</strong>：遵守策略协议的对象。</li>
</ul>

<p>UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1538047244.png" alt="" /></p>

<!-- more -->

<h2 id="when-should-you-use-it">When should you use it?</h2>
<p>当你有两个或多个需要交换的表现时需要使用策略模式。
这个模式和委托模式相似：因为两个模式都是依赖于协议而不出具体对象来提高弹性。通常，任何实现了策略协议的对象可以在运行时被用做协议对象。
不想委托，策略模式使用一系列对象。
委托经常在运行时确定。比如，<code class="highlighter-rouge">UITableView</code>的<code class="highlighter-rouge">dataSource</code>和<code class="highlighter-rouge">delegate</code>可以在 Interface Builder 中设置，但是它们在运行时很少改变。
然而，策略的目的是在运行时可以轻松的交换。</p>

<h2 id="playground-example">Playground example</h2>

<p>策略模式是一种表现型模式，因为策略模式是关于一个对象使用另一个对象来做一些事情。
下面的代码例子是一个关于电影评分的例子。想象一个 app 使用几个电影评分服务。比如：烂番茄，IMDb和Metacritic。为了不重复为每种服务写代码，我们来使用策略模式来简化实现。可以创建一个定义了通用 API 的协议来获取每种服务。
首先我们定义一个策略协议：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">MovieRatingStrategy</span> <span class="p">{</span>
	<span class="c1">// 1</span>
	<span class="k">var</span> <span class="nv">ratingServiceName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
	
	<span class="c1">// 2</span>
	<span class="kd">func</span> <span class="nf">fetchRating</span><span class="p">(</span><span class="k">for</span> <span class="nv">movieTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
					 <span class="nv">success</span><span class="p">:</span> <span class="p">(</span><span class="n">_</span> <span class="nv">rating</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">review</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>
<ol>
  <li>我们使用<code class="highlighter-rouge">ratingServiceName</code>来表示提供评分的服务。比如：它可能是烂番茄。</li>
  <li>我们使用<code class="highlighter-rouge">fetchRatingForMovieTitle(_:success:)</code>来获取异步获取电影评分。在真实的 app 中，可能需要一个失败的 closure。</li>
</ol>

<p>接下来，添加烂番茄客户端的实现代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">RottenTomatoesClient</span><span class="p">:</span> <span class="kt">MovieRatingStrategy</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="k">let</span> <span class="nv">ratingServiceName</span> <span class="o">=</span> <span class="s">"Rotten Tomatoes"</span>
	
	<span class="kd">public</span> <span class="kd">func</span> <span class="nf">fetchRating</span><span class="p">(</span>
		<span class="k">for</span> <span class="nv">movieTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
		<span class="nv">success</span><span class="p">:</span> <span class="p">(</span><span class="n">_</span> <span class="nv">rating</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">review</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
		
		<span class="c1">// In a real service, you'd make a network request...</span>
		<span class="c1">// Here, we just provide dummy values...</span>
		<span class="k">let</span> <span class="nv">rating</span> <span class="o">=</span> <span class="s">"95%"</span>
		<span class="k">let</span> <span class="nv">review</span> <span class="o">=</span> <span class="s">"It rocked!"</span>
		<span class="nf">success</span><span class="p">(</span><span class="n">rating</span><span class="p">,</span> <span class="n">review</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>然后，添加 IMDb 客户端的实现代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">IMDbClient</span><span class="p">:</span> <span class="kt">MovieRatingStrategy</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="k">let</span> <span class="nv">ratingServiceName</span> <span class="o">=</span> <span class="s">"IMDb"</span>
	
	<span class="kd">public</span> <span class="kd">func</span> <span class="nf">fetchRating</span><span class="p">(</span>
		<span class="k">for</span> <span class="nv">movieTitle</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span>
		<span class="nv">success</span><span class="p">:</span> <span class="p">(</span><span class="n">_</span> <span class="nv">rating</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">review</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
		
		<span class="k">let</span> <span class="nv">rating</span> <span class="o">=</span> <span class="s">"3 / 10"</span>
		<span class="k">let</span> <span class="nv">review</span> <span class="o">=</span> <span class="s">"""
	  It was terrible! The audience was throwing rotten
	  tomatoes!
	  """</span>
		<span class="nf">success</span><span class="p">(</span><span class="n">rating</span><span class="p">,</span> <span class="n">review</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>因为所有提供服务的客户端都遵守了<code class="highlighter-rouge">MovieRatingStrategy</code>。使用策略的对象不必要直接指导它们的类型，代替的，它们仅仅依赖协议。
作为例子，添加下面代码：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">MoviewRatingViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
	
	<span class="c1">// MARK: - Properties</span>
	<span class="kd">public</span> <span class="k">var</span> <span class="nv">movieRatingClient</span><span class="p">:</span> <span class="kt">MovieRatingStrategy</span><span class="o">!</span>
	
	<span class="c1">// MARK: - Outlets</span>
	<span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">movieTitleTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
	<span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">ratingServiceNameLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
	<span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">ratingLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
	<span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">reviewLabel</span><span class="p">:</span> <span class="kt">UILabel</span><span class="o">!</span>
	
	<span class="c1">// MARK: - View Lifecycle</span>
	<span class="kd">public</span> <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
		<span class="n">ratingServiceNameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span>
			<span class="n">movieRatingClient</span><span class="o">.</span><span class="n">ratingServiceName</span>
	<span class="p">}</span>
	
	<span class="c1">// MARK: - Actions</span>
	<span class="kd">@IBAction</span> <span class="kd">public</span> <span class="kd">func</span> <span class="nf">searchButtonPressed</span><span class="p">(</span><span class="nv">sender</span><span class="p">:</span> <span class="kt">Any</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">guard</span> <span class="k">let</span> <span class="nv">movieTitle</span> <span class="o">=</span> <span class="n">movieTitleTextField</span><span class="o">.</span><span class="n">text</span>
			<span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
		
		<span class="n">movieRatingClient</span><span class="o">.</span><span class="nf">fetchRating</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">movieTitle</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="n">rating</span><span class="p">,</span> <span class="n">review</span><span class="p">)</span> <span class="k">in</span>
			<span class="k">self</span><span class="o">.</span><span class="n">ratingLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">rating</span>
			<span class="k">self</span><span class="o">.</span><span class="n">reviewLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">review</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>当这个 view controller 在 app 中实例化时，需要设置<code class="highlighter-rouge">movieRatingClient</code>属性。注意，view controller 不知道<code class="highlighter-rouge">MovieRatingStrategy</code>具体实现。
使用哪个 MovieRatingStrategy 的决定可以推迟到运行时，可以让用户选择。</p>

<h2 id="what-should-you-be-careful-about">What should you be careful about？</h2>

<p>小心滥用这个模式。实际情况下，如果一个表现不会改变，可以直接放到使用的view controller 或者对象的上下文中。使用这个模式得技巧是知道什么时候切换行为。并且可以在确定需要的地方 lazy 的去做。</p>

<h2 id="tutorial-project">Tutorial project</h2>

<p>我们接着委托模式继续做那个 app。我们添加一个可以随机顺序回答问题的机制。这样我们就可以不按顺序回答问题了。但是，有些人可能想要顺序回答问题。这里我们用策略模式来实现。实现效果：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/2018-09-28%2012.06.40.gif" width="375px" />
<a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Strategy">Demo</a></p>
<h2 id="预告">预告</h2>
<p>下节将介绍单例模式。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design Patterns by Tutorials》笔记——Delegation Pattern</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Delegation-Pattern</link>
	  <author>Freelf</author>
	  <pubDate>2018-08-16T16:44:01+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-Delegation-Pattern</guid>
	  <description><![CDATA[
	     <p>委托模式使一个对象能够使用另一个对象来提供数据或者执行一些任务，这个模式有三个部分，UML 图如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15344108237603.jpg" alt="" />
<!-- more --></p>
<ul>
  <li>一个<strong>对象需要委托</strong>：也就是委托对象。通常这个对象有一个<code class="highlighter-rouge">weak</code> 属性 <code class="highlighter-rouge">delegate</code>，防止循环引用。</li>
  <li>一个<strong>委托协议</strong>：这个协议定义了委托应该实现或者可能实现的方法。</li>
  <li>一个<strong>委托</strong>：实现委托方法的对象。</li>
</ul>

<p>通过依赖一个委托协议代替一个混合对象使得实现更加有弹性，只要一个对象实现了协议就可以作为一个委托对象。</p>
<h2 id="什么时候使用">什么时候使用</h2>
<p>使用委托模式可以拆分大型类或者创建通用的、可重用的组件。委托关系在 Apple 的框架中很常见，尤其是 <code class="highlighter-rouge">UIKit</code>。名字中有 <code class="highlighter-rouge">DataSource</code> 和 <code class="highlighter-rouge">Delegate</code> 的对象实际上都遵守了代理模式。
在 Apple 的框架中为什么不是一个协议，而是两个？
Apple 的框架通常使用 <code class="highlighter-rouge">DataSource</code> 来对提供数据的委托方法进行分组，使用 <code class="highlighter-rouge">Delegate</code> 来对接收数据或者事件的委托方法分组。比如：<code class="highlighter-rouge">UITableViewDataSource</code> 是想要提供一个 <code class="highlighter-rouge">UITableViewCell</code> 来展示， <code class="highlighter-rouge">UITableViewDelegate</code> 通知那行被选中了。
通常 <code class="highlighter-rouge">dataSource</code> 和 <code class="highlighter-rouge">delegate</code> 被设置为一个对象，比如拥有 <code class="highlighter-rouge">UITableView</code>的 view controller。然而，不是必须这样做。把它设置到另一个对象更有好处。</p>
<h2 id="playground-example">Playground example</h2>
<p>委托协议是一个表现类型的设计模式。这是因为委托都是一个对象和另一个对象交流有关。
下面的代码将创建一个<code class="highlighter-rouge">MenuViewController</code>，这个 VC 有一个 <code class="highlighter-rouge">tableView</code>，并且是这个 <code class="highlighter-rouge">tableView</code> 的委托和数据源。
首先创建 <code class="highlighter-rouge">MenuViewController</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">class</span> <span class="kt">MenuViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
  <span class="c1">// 1</span>
  <span class="kd">@IBOutlet</span> <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span> <span class="p">{</span>
    <span class="k">didSet</span> <span class="p">{</span>
      <span class="n">tableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
      <span class="n">tableView</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 2</span>
  <span class="k">let</span> <span class="nv">items</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Item 1"</span><span class="p">,</span> <span class="s">"Item 2"</span><span class="p">,</span> <span class="s">"Item 3"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>
<p>添加下面的代码，设置 <code class="highlighter-rouge">MenuViewController</code> 为 <code class="highlighter-rouge">tableView</code> 的数据源和委托：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - UITableViewDataSource</span>
<span class="kd">extension</span> <span class="kt">MenuViewController</span><span class="p">:</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
  
  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
                 <span class="n">cellForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
                 <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> 
      <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCell</span><span class="p">(</span><span class="nv">withIdentifier</span><span class="p">:</span> <span class="s">"Cell"</span><span class="p">,</span>
                                    <span class="nv">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">textLabel</span><span class="p">?</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">cell</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
                 <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">count</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MARK: - UITableViewDelegate</span>
<span class="kd">extension</span> <span class="kt">MenuViewController</span><span class="p">:</span> <span class="kt">UITableViewDelegate</span> <span class="p">{</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
                 <span class="n">didSelectRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// To do next....</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">UITableViewDelegate</code> 和 <code class="highlighter-rouge">UITableViewDataSource</code> 都是委托协议，他们定义了委托对象必须实现的方法。
可以非常简单的定义你自己的委托。比如：你可以创建一个委托来通知用户点击的 menuItem：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">MenuViewControllerDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">menuViewController</span><span class="p">(</span> <span class="n">_</span> <span class="nv">menuViewController</span><span class="p">:</span> <span class="kt">MenuViewController</span><span class="p">,</span> <span class="n">didSelectItemAtIndex</span> <span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>接下来，给 <code class="highlighter-rouge">MenuViewController</code> 添加一个属性：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">delegate</span><span class="p">:</span> <span class="kt">MenuViewControllerDelegate</span><span class="p">?</span>
</code></pre></div></div>
<p>iOS 中的习惯是当一个对象创建后来设置委托对象。所以，当创建一个 <code class="highlighter-rouge">MenuViewController</code> 后，来设置它的委托对象。
最后，当用户点击一个 item，你应该去通知委托对象。我们把 <code class="highlighter-rouge">tableView</code> 委托的 <code class="highlighter-rouge">didSelectd</code> 方法添加以下方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delegate</span><span class="p">?</span><span class="o">.</span><span class="nf">menuViewController</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">didSelectItemAtIndex</span><span class="p">:</span> <span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
</code></pre></div></div>
<p>在委托方法中，一般我们都把需要委托的对象作为参数传过去，在这个例子中就是 <code class="highlighter-rouge">MenuViewController</code>，这样，委托对象就可以在需要的时候去使用或者检查调用者了。
现在，你已经创建了你自己的委托协议，在一个真实的 app 中，item 在被点击了经常需要处理一些逻辑，比如跳转到一个新的视图。</p>
<h2 id="应该注意的地方">应该注意的地方</h2>
<p>委托非常有用，但是经常被滥用。不要为一个对象创建太多的委托。如果一个对象需要几个委托，可能表示这个类做了太多事情。这是应该考虑为特定的情况分解对象的功能，而不是一个包罗万象的类。
很难说清楚多少是多，但是有一个黄金法则。如果你经常在两个类之间来回切换来了解发生了什么，那就说明太多了。同样的，如果你不能理解某个委托的用处，也说明太多了。</p>
<h2 id="教程项目">教程项目</h2>
<p>上一篇 MVC 之后，我们已经实现了可以一些功能，比如，点击屏幕可以显示答案，点击正确和错误按钮可以记录正确和错误的个数。
接下来我们需要实现让用户可以选择问题组的一个列表，并且在 <code class="highlighter-rouge">QuestionViewControlle</code> 中添加了取消按钮、显示当前问题下标和回答完问题再点击正确或者错误按钮返回的操作。这些操作使用委托模式实现。具体效果如下图：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/delegate.gif" width="375px" /></p>
<h2 id="预告">预告</h2>
<p>下一章我们会学习策略模式，并且继续完善 RabbleWabble。
<a href="https://github.com/zhangdongpo/LearnDesignPattern/tree/Delegate">Demo地址</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design Patterns by Tutorials》笔记——MVC</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-MVC</link>
	  <author>Freelf</author>
	  <pubDate>2018-08-16T16:15:13+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-MVC</guid>
	  <description><![CDATA[
	     <p>MVC 设计模式把对象分为三个不同的类型： Models，Views和 Controllers。
UML 图表示如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15341242390937.jpg" alt="" />
<!-- more -->
MVC 是在 iOS 编程中是非常常见的，因为 Apple 在 UIKit 中大量选用了这种设计模式。</p>
<ul>
  <li><strong>Models</strong>保持应用数据，通常为 structs 或者简单的 classes。</li>
  <li><strong>Views</strong>在屏幕上显示看的见的元素和 controls，通常为<code class="highlighter-rouge">UIView</code>的子类。</li>
  <li><strong>Controllers</strong>在 models 和 views 中间协调，通常为<code class="highlighter-rouge">UIViewController</code>的子类。</li>
</ul>

<p>Controllers 允许对它的 model 和 view 强引用，所以它可以直接操作model 和 view。Controllers 可以有不止一个 model 或者 view。
相反的，models 和 views 不应该保持他们所属 controller 的强引用。这会导致一个循环引用。
作为替代，通过属性监听，models 和它们的 controller 进行通信。views 通过<code class="highlighter-rouge">IBAction</code>和 controller 进行通信。
这可以让你在几个 controllers 中可以复用 models 和 views。</p>
<blockquote>
  <p>注意：Views 可能有一个弱引用 delegate 指向拥有它的 controller。比如，一个 <code class="highlighter-rouge">UITableView</code>可能持有一个拥有它的 view controller 弱引用作为它的 <code class="highlighter-rouge">delegate</code> 或者 <code class="highlighter-rouge">dataSource</code>。然而，table view 不用明确知道这是拥有它的 view controller。
Controllers 非常难以复用，因为它们的逻辑是非常具体的描述它们所做的任务。因此，MVC 不尝试去复用 Controllers。</p>
  <h2 id="什么时候使用-mvc">什么时候使用 MVC</h2>
  <p>一般我们一开始做一个 app 时，我们使用 MVC。
接下来，我们可能使用除了 MVC 额外的设计模式，但是没关系，在需要时我们再引入更多的设计模式。</p>
  <h2 id="playground-example">Playground example</h2>
  <p>设计模式可以分为三类</p>
  <ul>
    <li>结构类型：描述一个大的子系统如何组合对象。</li>
    <li>表现类型：描述对象如何和其他对象联系。</li>
    <li>创建类型：创建对象。</li>
  </ul>
</blockquote>

<p>很明显，MVC 是一个结构类型的模式。
接下来，我们看一下如何组合对象，来构成一个地址屏幕 app。
model：</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - Address</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Address</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">street</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">city</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">zipCode</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
</code></pre></div></div>
<p>view：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - AddressView</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">AddressView</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">streetTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">cityTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">stateTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
    <span class="kd">@IBOutlet</span> <span class="kd">public</span> <span class="k">var</span> <span class="nv">zipCodeTextField</span><span class="p">:</span> <span class="kt">UITextField</span><span class="o">!</span>
<span class="p">}</span>
</code></pre></div></div>
<p>controller：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - AddressViewController</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">AddressViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    
    <span class="c1">// MARK: - Properties</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">address</span><span class="p">:</span> <span class="kt">Address</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="nf">updateViewFromAddress</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">addressView</span><span class="p">:</span> <span class="kt">AddressView</span><span class="o">!</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="n">isViewLoaded</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">view</span> <span class="k">as!</span> <span class="kt">AddressView</span>
    <span class="p">}</span>
    <span class="c1">// MARK: - View Lifecycle</span>
    <span class="kd">public</span> <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
        <span class="nf">updateViewFromAddress</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">updateViewFromAddress</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">addressView</span> <span class="o">=</span> <span class="n">addressView</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">address</span> <span class="o">=</span> <span class="n">address</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">addressView</span><span class="o">.</span><span class="n">streetTextField</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">street</span>
        <span class="n">addressView</span><span class="o">.</span><span class="n">cityTextField</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">city</span>
        <span class="n">addressView</span><span class="o">.</span><span class="n">stateTextField</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">state</span>
        <span class="n">addressView</span><span class="o">.</span><span class="n">zipCodeTextField</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">zipCode</span>
    <span class="p">}</span>
    <span class="c1">// MARK: - Actions</span>
    <span class="kd">@IBAction</span> <span class="kd">public</span> <span class="kd">func</span> <span class="nf">updateAddressFromView</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">AnyObject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">street</span> <span class="o">=</span> <span class="n">addressView</span><span class="o">.</span><span class="n">streetTextField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">street</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">city</span> <span class="o">=</span> <span class="n">addressView</span><span class="o">.</span><span class="n">cityTextField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">city</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">state</span> <span class="o">=</span> <span class="n">addressView</span><span class="o">.</span><span class="n">stateTextField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="k">let</span> <span class="nv">zipCode</span> <span class="o">=</span> <span class="n">addressView</span><span class="o">.</span><span class="n">zipCodeTextField</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">zipCode</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// TO-DO: show an error message, handle the error, etc</span>
                <span class="k">return</span>
        <span class="p">}</span>
        <span class="n">address</span> <span class="o">=</span> <span class="kt">Address</span><span class="p">(</span><span class="nv">street</span><span class="p">:</span> <span class="n">street</span><span class="p">,</span> <span class="nv">city</span><span class="p">:</span> <span class="n">city</span><span class="p">,</span>
                          <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">zipCode</span><span class="p">:</span> <span class="n">zipCode</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们在，<code class="highlighter-rouge">address</code>属性变化时去更新 <code class="highlighter-rouge">view</code>，并且在 <code class="highlighter-rouge">view</code>有交互时通过<code class="highlighter-rouge"> IBAction</code>去更新 <code class="highlighter-rouge">model</code>。
上面只是给出了一个简单的例子来表示 MVC 是如何工作的。我们可以看到 controller 如何持有 model 和 views，并且通过 controller 交互。</p>
<h2 id="使用时应该注意的地方">使用时应该注意的地方</h2>
<p>MVC 是一个好的开始，但是它有局限性。不是每一个对象都能很好的归类于 model，view ，controller 的范围中。因此，只是用 MVC 的应用在 controllers 中有很多逻辑，导致 view controller 越来越大。
为了解决这个问题，需要在需要时引入其他的设计模式。</p>
<h2 id="教程项目">教程项目</h2>
<p>通过这一整章，我们会做一个应用叫做：Rabble Wabble(就是一个类似背单词的 app)。这一小篇的效果如下：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/MVC.gif" alt="MVC" />
功能类似一个背单词的 app，点击空白处显示答案，点正确，正确数加1，点错误错误数加1。很简单吧，利用这个功能，我们可以了解下 MVC 各个模块通信方式。通过下面的学习，我们将逐步完善这个应用。</p>

	  ]]></description>
	</item>

	<item>
	  <title>读《Design Patterns by Tutorials》笔记——UML图</title>
	  <link>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-UML%E5%9B%BE</link>
	  <author>Freelf</author>
	  <pubDate>2018-08-10T16:24:17+00:00</pubDate>
	  <guid>//%E8%AF%BB-Design-Patterns-by-Tutorials-%E7%AC%94%E8%AE%B0-UML%E5%9B%BE</guid>
	  <description><![CDATA[
	     <p>在学习设计模式之前，需要先来学习 UML 图。为什么先要学习 UML 图呢？因为后面的设计模式，我们都可以用一幅 UML 图来表示，所以当我们看到一幅 UML 图，就可以明白这是什么设计模式。然后如何用代码去实现它。
<!-- more --></p>
<h2 id="什么是-uml-图">什么是 UML 图</h2>
<p>UML 图包含类、协议、属性、方法和关系。
一个方块表示一个类。下面有一个非常简单的类 Dog：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1534068645.png" alt="Dog" />
为了表示一个类继承另外一个类，使用一个空心箭头：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1534068758.png" alt="继承" />
但是我们通常不把空心箭头叫做“inherits from”，而是叫成“is a”，例如：可以用下面的图表示 SheepDog 继承自 Dog 。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340697063981.jpg" alt="" />
我们可以这样来理解这个图“SheepDog 是一个 Dog”。
在 UML 中使用一个简单的箭头表示属性，在 UML 中叫做“关联”。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340698551173.jpg" alt="" />
通常把属性这个箭头叫做“has a”，比如下图：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340699550757.jpg" alt="" />
也可以通过在箭头下面描述一个区间来表示一对多的关系，如下图表示一个 Farmer 有好多 Dog：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340700470394.jpg" alt="" />
可以在一个 UML 图中使用多个箭头和方块，下面这个图表示一个 Farmer 有一个 SheepDog，这个  SheepDog 是一个 Dog。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340702450982.jpg" alt="" />
在 UML 图中，也可以使用方块表示一个协议，为了区别类，需要在协议名前面加上«protocol»。
下图表示一个 PetOwning 协议：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340703702062.jpg" alt="" />
使用一个空心箭头和虚线来表示一个类遵守了一个协议：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340704239696.jpg" alt="" />
你可以把它理解成“实现”或者“符合”。
使用一个普通箭头和虚线来表示依赖。ULM 有意模糊依赖的概念。因此，无论什么时候使用依赖的关系都应该注释上使用的目的。比如，可以使用依赖箭头表示以下情况：</p>
<ul>
  <li>一个 weak 属性或者 delegate；</li>
  <li>一个作为参数传递给一个方法的对象，并且没有作为属性引用；</li>
  <li>一种松耦合或者回调，比如：一个从 view 到 controller 的 IBAction</li>
</ul>

<p>下图表示 Dog 代理到 PetOwning 对象：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340823104115.jpg" alt="" />
也可以在 ULM 中表示属性和方法，例如，下图表示 PetOwning 协议有一个 name 属性和 petNeedsFood(_:)方法：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340824409631.jpg" alt="" />
如果一个箭头的意义很明确，可以删除一些解释性文字，通常可以删除继承，属性和实现的解释文字。然而，应该保留依赖的文字。因为，他们的意义通常不太明确。
下面是一副表示 Farmer 和 Dog 的完整的 UML 图。Dog 代理到 PetOwning 对象。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/15340826726564.jpg" alt="" />
UML 图是学习设计模式得基础，我们已经简单学了一些基础的 UML 图。下面将去学习一些设计模式。</p>

	  ]]></description>
	</item>

	<item>
	  <title>iOS UI开发捷径读书笔记一——基础概念理解</title>
	  <link>//UI%E5%BC%80%E5%8F%91%E6%8D%B7%E5%BE%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</link>
	  <author>Freelf</author>
	  <pubDate>2018-01-22T09:57:39+00:00</pubDate>
	  <guid>//UI%E5%BC%80%E5%8F%91%E6%8D%B7%E5%BE%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0</guid>
	  <description><![CDATA[
	     <p>最近读了《iOS UI开发捷径–利用Interface Builder高效、优雅地开发UI》这本书。感觉受益匪浅，记录下自己在书里面学到的东西。这里只写自己学到的新知识，并不介绍一些简单的IB知识，想要具体学习，请买书自己学习。
<!-- more --></p>
<h2 id="和interface-builder有关的几个重要概念">和Interface Builder有关的几个重要概念</h2>
<p>下面介绍几个和IB有关的概念，学习下平常经常用，但是不了解的概念。</p>
<h3 id="bundle">Bundle</h3>
<p>这个我们在平常工作中应该经常用，比如创建IB的时候，还有获取资源路径的时候：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let bundle = Bundle.main
</code></pre></div></div>
<p>Bundle有两种表现形式：</p>
<ol>
  <li>保存可执行代码，比如我们整个App就是一个Bundle，也就是我们经常用的main bundle。</li>
  <li>保存需要的资源。这里的资源包括XIB，Storyboard，图片，声音等，例如我们在使用一些第三方的SDK时用的bundle。
    <h3 id="nib">nib</h3>
    <p>我们创建XIB时，经常调用的方法是<code class="highlighter-rouge">loadNibName</code>，为啥是loadNib，而不是loadXIB呢。这里就少说一下XIB和nib的关系了，XIB用Source Code的方式显示可以看到其实他就是个xml文件，那么nib是什么呢，通俗的解释下，nib是工程被编译后，由XIB生成的一种文件类型。这里可以看出XIB和其他资源文件的不同，XIB是需要经过编译的，编译后XIB就不存在了，而在Bundle中生成了与之对应的nib文件，而其他文件只是简单的copy到bundle中。Storyboardc和Storyboard的对应关系和XIB和nib的对应关系是一样的。</p>
    <h2 id="使用xib应该注意的事情">使用XIB应该注意的事情</h2>
    <p>下面看下使用XIB时，应该注意的事情。</p>
    <h3 id="files-owner的使用">File‘s Owner的使用</h3>
    <p>在XIB文件中，左侧文件排列上，我们可以看到有一个File‘s Owner。从字面上理解，File‘s Owner就是文件的所有者。一般我们的File‘s Owner都是VC。这里为什么介绍File‘s Owner，是因为一个XIB可以同时和UIView和UIViewController进行连线，这里依靠的就是File‘s Owner。例如，一个XIB文件中，一个view即可以和File‘s Owner连线也可以和自己的view文件连线，这样就可以在view中处理一些view的逻辑，在VC中处理业务逻辑了。使用File‘s Owner时还应该注意的地方是，当创建XIB时，调用的函数：</p>
  </li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func loadNibNamed(_ name: String, owner: Any?, options: [AnyHashable : Any]? = nil)
</code></pre></div></div>
<p>这里的owner参数，我们经常传入nil，这里要说下这个参数具体情况下应该传入什么，</p>
<ol>
  <li>当XIB没有设置File‘s Owner那么这里传入nil</li>
  <li>当XIB设置File‘s Owner并且对应类就是使用XIB的这个类，这里可以传入self或者nil</li>
  <li>当XIB设置的File‘s Owner不是当前使用该XIB文件的类，这里就必须传入与File‘s Owner相对应的类。
    <h3 id="uinib的使用">UINib的使用</h3>
    <p>加载XIB文件的方式有以下两种：</p>
  </li>
  <li><code class="highlighter-rouge">func loadNibNamed(_ name: String, owner: Any?, options: [AnyHashable : Any]? = nil)</code></li>
  <li><code class="highlighter-rouge">open func instantiate(withOwner ownerOrNil: Any?, options optionsOrNil: [AnyHashable : Any]? = nil) -&gt; [Any]</code>
这两种方法有啥不同的呢，第一种是频繁的加载XIB文件，第二种是利用UINib把XIB文件加载到内存中，然后从内存中加载。所以当我们需要频繁使用XIB文件时要用第二种，但只用一次时，应该用第一种。
    <h3 id="uiviewcontroller和xib的使用">UIViewController和XIB的使用</h3>
    <p>当我们创建VC时如果没有勾选also create XIB，后面又想使用XIB，我们就应该手动创建XIB，然后进行关联，关联的时候，我们需要把view和VC的view属性进行连线，否则程序会crash。</p>
    <h2 id="xib和autolayout">XIB和AutoLayout</h2>
    <p>这里不具体介绍AutoLayout，只介绍几个属性，新学到的。</p>
    <h3 id="content-compression-resistance">Content Compression Resistance</h3>
    <p>这个属性是指一个视图保护其内容完整性的能力，系数越大，改视图保护内容完整性越强，内容越不容易被压缩或者裁剪。</p>
    <h3 id="content-hugging">Content Hugging</h3>
    <p>这个属性是指一个视图保护它的尺寸与其内容尺寸相匹配的能力，系数越大，匹配能力越强。</p>
    <h3 id="在xib中scrollview使用autolayout">在XIB中ScrollView使用AutoLayout</h3>
    <p>ScrollView使用AutoLayout和其他view不同，我们需要设置它的子view大小明确，因为ScrollView需要计算自己的contentSize。所以原则是他的子view的约束需要可以推算出ScrollView的contentSize。</p>
    <h2 id="storyboard使用">Storyboard使用</h2>
    <p>Storyboard平常的使用和XIB差不多，但是Storyboard比XIB多了Extra View，segue和object的使用，这里我们主要介绍extra view，segue和object的使用。</p>
    <h3 id="extra-view">Extra View</h3>
    <p>我们通常会有这样的需求，一个VC在特定的情况下或者固定的操作后显示一个View，比如，没有网络的时候的提示页面。SB允许在Scene中添加Extra View来完成这些事情。下面介绍如何使用。我们拖一个View到First Responder和exit中间，如图所示：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com//1516606117.png" alt="" />
然后在这个View上面添加无网络时展示的控件，添加的控件可以直接拖到VC中进行连线，还可以和自定义的UIView类进行关联，封装使用。我们将这个View和VC进行连线，然后在VC中添加入下代码：</p>
  </li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ViewController: UIViewController {

    @IBOutlet weak var reachabilityView: UIView!
    override func viewDidLoad() {
        super.viewDidLoad()
        let noReachability = true
        if noReachability {
            reachabilityView.center = view.center
            self.view.addSubview(reachabilityView)
        }
    }
｝
</code></pre></div></div>
<h2 id="预告">预告</h2>
<p>Segue、Storyboard reference、Object其实可以单独写篇文章，这里先暂时不介绍了，等写完文章附上地址。</p>


	  ]]></description>
	</item>

	<item>
	  <title>读Objective-C高级编程笔记一——引用计数</title>
	  <link>//%E8%AF%BBObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0</link>
	  <author>Freelf</author>
	  <pubDate>2017-08-15T23:27:57+00:00</pubDate>
	  <guid>//%E8%AF%BBObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0</guid>
	  <description><![CDATA[
	     <p>最近读了《Objective-C高级编程》这本进阶书：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503026660.png" alt="Objective-C高级编程" />。
这本书有三章，我们先来介绍第一章。可以从下图看下第一章的整体结构。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503025584.png" alt="内存管理" />。
<!-- more -->
本篇是第一篇，来写下iOS的内存管理，其实iOS的内存管理无论是ARC还是MRC都是通过引用计数来管理的。每个对象都有一个<code class="highlighter-rouge">retainCount </code>的属性。当一个对象的<code class="highlighter-rouge">retainCount </code>为0，就说明没有地方使用该对象了，可以释放了。
我们先看MRC，再看ARC，因为ARC其实是建立在MRC之上的，只是是编译器在合适的地方代替我们插入了内存管理的代码。</p>

<h3 id="引用计数">引用计数</h3>

<p>前面我们一直在说引用计数，到底什么是引用计数呢？下图可以表达这个概念。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503068536.png" alt="照明管理" />
在Objective-C中，对象就相当于上图中的灯。使用计数功能计算需要照明的人数，办公室的灯得到了很好的管理。同样，使用引用计数功能，对象也能够得到很好的管理，这就是Objective-C的内存管理，如下图所示：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503071113.png" alt="引用计数的内存管理" /></p>

<h3 id="内存管理思考方式">内存管理思考方式</h3>

<p>下面我们来了解下引用计数式的内存管理思考方式。</p>
<ul>
  <li>自己生成的对象，自己持有。</li>
  <li>非自己生成的对象，自己也能持有。</li>
  <li>不再需要自己持有的对象时释放。</li>
  <li>非自己持有的对象不能释放。
其实引用计数式的内存管理思考方式仅此而已。除了上文提到的“生成”，“持有”，“释放”三种对对象的操作方式，还有一种“废弃”方式，各个词表示的Objective-C方法如下表：
| 对象操作                     | Objective-C方法
| 生成并持有对象         | alloc/new/copy/mutableCopy方法
| 持有对象                     | retain方法
| 释放对象                     | release方法
| 废弃对象                     | dealloc方法
这些有关Objective-C内存管理的方法，实际上不包括在该语言中，而是包含在Cocoa框架中用于iOS，OS X应用开发。Cocoa中Foundation框架库的<code class="highlighter-rouge">NSObject</code>类负责内存管理的职责。Objective-C内存管理的alloc/retain/release/dealloc方法分别指代NSObject累的alloc方法，retain方法，release方法和dealloc方法。
下面我们来详细了解下上面提到的内存管理思考方式。</li>
</ul>

<h4 id="自己生成的对象自己持有">自己生成的对象自己持有</h4>

<p>使用以下名称开头的方法名意味着自己生成并持有对象：</p>
<ul>
  <li>alloc</li>
  <li>new</li>
  <li>copy</li>
  <li>mutableCopy
例如：
  id obj = [[NSObject alloc]init]
这句话就自己生成并持有了对象，另外使用NSObject的new类也能自己生成并持有对象。<code class="highlighter-rouge">[NSObject new]</code>和<code class="highlighter-rouge">[[NSObject alloc]init]</code>是完全一样的。
同样的copy和mutableCopy方法也可以自己生成并持有对象。两者的差异就是copy生成的是不可变对象，而mutableCopy生成的是可变对象。
另外，下列名称也意味着自己生成并持有对象：</li>
  <li>allocMyObject</li>
  <li>newThisObject</li>
  <li>copyThis</li>
  <li>mutableCopyYourObject
但是对象一下名称，即使使用alloc/new/copy/mutableCopy名称开头，也并不属于同一类方法。</li>
  <li>allocate</li>
  <li>newer</li>
  <li>copying</li>
  <li>mutableCopyed
反正只要记得上面说的几个方法是自己生成并持有对象就好。</li>
</ul>

<h4 id="非自己生成的对象自己也能持有">非自己生成的对象自己也能持有</h4>

<p>因为是非自己生成并持有，所以该对象不是自己生成的，所以我们来使用上面说的几个方法外的方法试试。非常可以说明问题的就是NSMutableArray的array类方法：
	id obj = [NSMutableArray array];
上面代码中，其实obj是不持有生成的这个对象的，记得以前我还傻傻的以为这个和上面的一样会持有对象，结果一运行程序，直接崩溃了。我们可以使用retain方法来持有这个对象。</p>

<h4 id="不再需要自己持有的对象时释放">不再需要自己持有的对象时释放</h4>

<p>自己持有的对象，一旦不再需要，持有者有义务释放，使用release方法释放。无论是自己生成并持有的对象，还是通过retain方法持有的对象，在不需要时都需要通过release方法释放。下面我们来看下通过某个方法生成对象并将其return给调用方和调用<code class="highlighter-rouge">[NSMutableArray array] </code>方法取得对象的区别：</p>

<pre><code class="language--(id)allocObject">	{
	   id obj = [[NSObject alloc]init];
	   return obj;
	}
</code></pre>

<p>像上面这样，原封不动的返回生成并持有的对象，就能让调用方也持有该对象。和前面说的自己生成并持有没区别，为什么<code class="highlighter-rouge">[NSMutableArray array] </code>不行呢，下面我们来看下具体实现：</p>

<pre><code class="language--(id)object">	{
	  id obj = [[NSObject alloc]init];
	  [obj autorelease];
	  return obj;
	}
</code></pre>

<p>因为在这个里面使用了autorelease方法，使用这个方法，可以使取得的对象存在，但是自己并不持有该对象。autorelease提供了使对象在超出制定生存范围时能够自动并正确的释放，后面我们会对autorelease进行详细的说明。下图是autorelease和release的区别:
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503112187.png" alt="autorelease和release的区别" /></p>

<h4 id="无法释放非自己持有的对象">无法释放非自己持有的对象</h4>

<p>这点就非常好理解了，不是自己持有的对象自己干嘛要去释放，像下面代码就会导致程序崩溃：</p>

<p>```id obj = [ [NSObject alloc]init];
[obj release];
[obj release];</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
在执行过一次release之后，obj指向的对象已经释放，再执行release肯定要访问到对象，访问已经废弃的对象时就boom了。
上面的四项内容就是内存管理的思考方式，下面我们来介绍下操作引用计数的函数实现。

### alloc/retain/release/dealloc实现

#### GNUstep的实现

GNUstep是Cocoa框架的互换框架。所以理解了GNUstep就相当于理解了Cocoa框架的实现。
我们先来看下alloc方法的实现：

```+(id)alloc
	{
	       return [self allocWithZone:NSDefaultMallocZone()];
	}
	+(id)allocWithZone:(NSZone *)z
	{
	      return NSAllocateObject(self,0,z);
	}
</code></pre></div></div>

<p>通过上面两个方法，我们看到其实最根本调用的是NSAllocateObject这个方法。下面我们来看看NSAllocateObject这个方法的实现：</p>

<p>```struct obj_layout
	{
	    NSUInteger retained;
	}</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inline id NSAllocateObject(Class aClass,NSUInteger extraBytes,NSZone *zone)
{
     int size = 计算容纳对象大小的size；
     id new = NSZoneMalloc(zone,size);//分配对象内存
     memset(new,0,size);//初始化内存
     new = (id) &amp;  ((struce obj_layout *) new)[1];
} ```
</code></pre></div></div>

<p>NSZone是为了防止内存碎片化引入的结构，想要了解更多，那只能自己看书了，这里我们只介绍alloc方法操作引用计数的实现。
下面是去掉NSZone之后的源代码：</p>

<p>```struct obj_layout
	{
	    NSUInteger retained;
	}
	+(id)alloc
	{
	     int size = sizeof(struct obj_layout) + 对象的大小；
	     struct obj_layout *p = (struct obj_layout *)calloc(1,size); //将引用计数写入对象内存头部
	     return (id)(p + 1); //返回对象的初始地址
	}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
alloc方法用struct `obj_layout`中的retained来保存引用计数，并将其写入对象内存头部，然后返回对象的初始地址。如下图所示：
![alloc返回对象的内存图](https://nightwish.oss-cn-beijing.aliyuncs.com/1503327298.png)
对象的引用计数可以通过retainCount来获得：

```id obj = [ [NSObject alloc]init];
	NSLog(@"retainCount = %d",[obj retainCount]);
	//显示为retainCount = 1；
执行alloc后对象的retainCount为1，下面我们来用GNUstep来看下原因：
	-(NSUInteger)retainCount
	{
	      return NSExtraRefCount(self) + 1;
	}
	inline NSUInteger NSExtraRefCount(id anObject)
	{
	    return ((struct obj_layout *)anObject)[-1].retained;  //这里这个-1，我是这么理解的，先把对象转成obj_layout类型，然后减去1个obj_layout指针大小，正好就指向obj_layout。下面的图更加明确的表示：
	}
</code></pre></div></div>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1505032536.png" alt="通过对象访问头像内存头部" />
因为分配时全部为0，所以retained为0.由 NSExtraRefCount(self)  + 1得出，retainCount为1.可以推测出，retain方法其实是让retained变量+1，二release方法使retained变量减1。
下面我们正好来看下retain方法的GNUstep实现：</p>

<pre><code class="language--(id)retain">	{
	    NSIncrementExtraRefCount(self);
	    return self;
	}
	inline void  NSIncrementExtraRefCount(id anObject)
	{
	    if(((struct obj_layout *)anObject)[-1].reatined == UINT_MAX - 1)
	        [NSException raise: NSInternalInconsistencyException format:@"NSIncrementExtraRefCount() asked to increment too far"];
	    ((struct obj_layout *)anObject)[-1].retained++;
	}
</code></pre>

<p>虽然写入了当retained变量超出最大值是发生的异常代码，但是实际上执行的是retained变量+1的代码。同样，release实例方法执行-1的代码，并且当引用计数变量为0时执行dealloc方法，下面我们来看下release的实现：</p>

<pre><code class="language--(void)release">	{
	    if(NSDecrementExtraRefCountWasZero(self))
	        [self dealloc]
	}
	BOOL  NSDecrementExtraRefCountWasZero(id anObject)
	{
	    if(((struct obj_layout *)anObject)[-1].retained == 0){
	        return YES;
	    }else{
	        ((struct obj_layout *)anObject)[-1].retained--;
	        return NO;
	    }
	}
</code></pre>

<p>和预想一样，release方法就是当retained变量大于0时减一，等于0时调用dealloc方法，废弃对象。（这里需要注意，我们调用retainedCount时，其实是retained变量+1，如果不是这样的话，那么会出现alloc后需要调用两次release才能dealloc）。下面我们来看下dealloc的实现：</p>

<pre><code class="language--(void)dealloc">	{
	    NSDeallocateObject(self);
	}
	inline void NSDeallocateObject(id anObject)
	{
	    struct obj_layout *o =  &amp;((struct obj_layout *)anObject)[-1];
	    free(0);
	}
</code></pre>

<p>以上就是alloc/retain/release/dealloc在GNUstep中的实现。具体的总结：</p>
<ul>
  <li>在OC对象中存有引用计数这一整数值。</li>
  <li>调用alloc和retain方法引用计数+1.</li>
  <li>调用release方法引用计数-1.</li>
  <li>当引用计数值为0时，调用dealloc方法释放对象。</li>
</ul>

<h4 id="苹果的实现">苹果的实现</h4>

<p>因为NSObject类的源代码没有公开，所以我们利用lldb大概追溯其大概的实现过程。在alloc方法上打断点，可以看到程序的执行顺序如下：</p>
<ol>
  <li>+alloc；</li>
  <li>+allocWithZone</li>
  <li>class_createInstance</li>
  <li>calloc
alloc方法首先调用allocWithZone:方法，这个和GNUstep是相同的。后面调用class_createInstance方法，这个方法可以在objc4的runtime/objc-runtime-new.mm中找到实现。然后再调用calloc来分配内存块。
retainCount/retain/release又是怎样实现的呢，我们用上面同样的方法可以看到retainCount/retain/release所执行的函数：</li>
</ol>

<pre><code class="language--retainCount">	__CFDoExternRefOperation
	CFBasicHashGetCountOfKey
	
	-retain
	__CFDoExternRefOperation
	CFBasicHashAddValue
	
	-release
	__CFDoExternRefOperation
	CFBasicHashRemoveValue
	CFBasicHashRemoveValue返回0事，-release调用dealloc
</code></pre>

<p>通过看上面三个方法，都调用了__CFDoExternRefOperation函数，这个函数的实现我们可以在CFRuntime.c中找到实现，下面是简化后的__CFDoExternRefOperation函数实现：</p>

<p>```int __CFDoExternRefOperation(uintptr_t op,id obj)
	{
	    CFBasicHashRef table = 取得对象的散列表(obj)；
	    int count;
	    switch(op){
	        case OPERATION_retainCount:
	        count = CFBasicHashGetCountOfKey(table,obj);
	        return count;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        case OPERATION_retain:
        CFBasicHashAddValue(table,obj);
        return obj;

        case OPERATION_release:
        cont = CFBasicHashRemoveValue(table,obj);
        return count == 0;
    }
} ```
</code></pre></div></div>

<p>__CFDoExternRefOperation函数按retainCount/retain/release操作进行分发，调用不同的函数，我们可以推断，NSObject类的retainCount/retain/release实例方法也许就如下面所示：</p>

<pre><code class="language--(NSUInteger)retainCount">	{
	    return (NSUInteger) \_\_CFDoExternRefOperation(OPERATION_retainCount,self);
	}
	-(id)retain
	{
	    return (id) \_\_CFDoExternRefOperation(OPERATION_retain,self);
	}
	-(void)release
	{
	    return  \_\_CFDoExternRefOperation(OPERATION_release,self);
	}

</code></pre>

<p>可以从__CFDoExternRefOperation函数实现来看，苹果的实现大概就是采用散列表来管理引用计数。
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1503473841.png" alt="通过散列表管理引用计数" />
GNUstep将引用计数保存在对象占用内存块头部的变量中，而苹果则是保存在引用计数表中。
通过内存块头部管理引用计数的好处：</p>
<ul>
  <li>写的代码少。</li>
  <li>能统一管理引用计数和对象内存块。
通过散列表管理引用计数的好处如下：</li>
  <li>对象内存块的分配不需要考虑内存块头部。</li>
  <li>引用计数表中存有内存块地址，可以从各个记录追溯到对象的内存块。
追溯内存块在调试时有着很重要的作用，即使出现故障导致对象占用的内存块损坏，只要引用计数表没坏，就可以确定内存块的位置。另外，再利用工具检测内存泄漏时，引用计数表的各记录也有助于检测个对象的持有者是否存在。</li>
</ul>

<h3 id="autorelease">autorelease</h3>

<p>说到内存管理，就不得不提autorelease，autorelease看上去很像ARC，但实际上它更类似于C语言中自动变量的特性，当自动变量超过其作用域，该自动变量就会被自动废弃。autorelease会像C语言的自动变量那样来对待对象的实例。当超出其作用域时，对象实例的release方法被调用。另外，同C语言的自动变量不同的是，我们可以设定变量的作用域。
autorelease的具体使用方法如下：</p>
<ol>
  <li>生成并持有NSAutoreleasePool对象；</li>
  <li>调用已分配对象的autorelease实例方法；</li>
  <li>废弃NSAutoreleasePool对象；
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1504753622.png" alt="NSAutoreleasePool对象的生命周期" />
NSAutoreleasePool对象的生存周期就相当于C语言变量的作用域，对于所有吊用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release方法。在Cocoa框架中，NSRunLoop对NSAutoreleasePool对象进行生成，持有和废弃处理。因此，我们不一定非得使用NSAutoreleasePool对象来进行开发工作。
尽管如此，但是在大量产生autorelease对象时，只要不废弃NSAutoreleasePool对象，那么生成的对象就不会释放，因此有时会产生内存不足的现象。典型的例子就是读入大量图像的同时改变其尺寸。图像文件读入到NSData对象，并从中生成UIImage对象，改变对象尺寸后生成新的UIImage对象。这种情况下，就会大量产生autorelease的对象。</li>
</ol>

<p>```for(int i = 0; i &lt; 图像数；i++){
	    //读入图像大量产生autorelease对象
	}
像上面这种情况，有必要在适当的地方生成，持有或废弃NSAutoreleasePool对象。
	for(int i = 0;i &lt; 图像数；i++){
	    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];
	    //读入图像
	    [pool drain];
	    通过drain，autorelease的对象被遗弃release。
	}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
另外，Cocoa框架中有很多类方法用于返回autorelease对象，比如NSMutableArray类的arrayWithCapacity类方法。
`id array = [NSMutableArray arrayWithCapacity:1];`
上面的代码等同于一下的源代码。
`id array = [[[NSMutableArray array]initWithCapacity:1]autorelease];`

### autorelease实现

#### GNUstep实现

我们先来看下GNUstep的实现:

```	-(id)autorelease
	{
	    [NSAutoreleasePool addObject:self];
	}
</code></pre></div></div>

<p>autorelease方法本质就是调用NSAutoreleasePool的addObject类方法。下面我们来看下NSAutoreleasePool类的实现，由于NSAutoreleasePool类的源代码比较复杂，我们假象一个简化的源代码进行说明。</p>

<pre><code class="language-+（void）addObject:（id）anObj">	{
	    NSAutoreleasePool *pool = 取得正在使用的NSAutoreleasePool对象；
	    if（pool ！= nil）{
	        [pool addObject:anObj];
	    }else{
	        NSLog（@"NSAutoreleasePool对象非存在在状态下吊用autorelease"）;
	    }
	}
</code></pre>

<p>addObject类方法调用正在使用的NSAutoreleasePool对象的addObject实例方法。如果嵌套生成或持有NSAutoreleasePool对象，理所当然会使用最内侧的对象。下面来看下addObject实例方法的实现。</p>

<pre><code class="language--（void）addObject：（id）anObj">	{
	    [array addObject:anObj];
	}
</code></pre>

<p>实际的GNUstep使用的是连接列表，同在NSMutableArray对象中添加对象是一样的。
如果调用NSObject类的autorelease实例方法，该对象被追加到正在使用的NSAutoreleasePool对象中的数组里。
下面我们看下drain方法废弃正在使用NSAutoreleasePool对象的过程。</p>

<pre><code class="language--（void）drain">	{
	    [self dealloc];
	}
	-（void）dealloc
	{
	    [self emptyPool];
	    [array release];
	}
	-（void）emptyPool
	{
	    for(id obj in array){
	        [obj release];
	    }
	}
</code></pre>

<p>虽然调用了好几个方法，但可以确定对于数组中的所有对象都调用了release方法。</p>

<h4 id="苹果的实现-1">苹果的实现</h4>

<p>可以通过objc4的runtime/NSObject.mm来看苹果的autorelease实现。</p>

<p>```class AutoreleasePoolPage
	{
	    static inline void *push()
	    {
	        相当于生成或持有NSAutoreleasePool类对象；
	    }
	    static inline void pop(void *token) 
	    {
	        相当于废弃NSAutoreleasePool类对象；
	        releaseAll();
	    }
	    static inline id autorelease(id obj)
	    {
	        这个相当于NSAutoreleasePool类的addObject类方法
	        AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的AutoreleasePoolPage实例；
	        autoreleasePoolPage-&gt;add(obj)；
	    }
	    id *add(id obj)
	    {
	        将对象追加到内部数组中；
	    }
	    void releaseAll()
	    {
	        调用内部数组中对象的release方法；
	    }
	};
	void *
	objc_autoreleasePoolPush(void)
	{
	    return AutoreleasePoolPage::push();
	}
	void
	objc_autoreleasePoolPop(void *ctxt)
	{
	    AutoreleasePoolPage::pop(ctxt);
	}</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>我们可以看下我们再使用NSAutoreleasePool时对应代码的实现：

```NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];
	/*等同于objc_autoreleasePoolPush()*/
	id obj = [[NSObject alloc]init];
	[obj autorelease];
	/*等同于objc_autorelease()*/
	[NSAutoreleasePool showPools];
	//将NSAutoreleasePool的状况输出到控制台。
	[pool drain];
	/*等同于objc_autoreleasePoolPop(pool)*/
</code></pre></div></div>

<p>另外， 不能autorelease NSAutoreleasePool对象。</p>

<h3 id="arc">ARC</h3>

<p>实际上“引用计数式内存管理”的本质在ARC中并没有改变，ARC只是自动帮助我们处理了“引用计数”的相关部分。所以MRC的内存管理思考方式在ARC下也是可行的。只是在源代码的记述方法上稍有不同。想要了解这些变化就需要理解ARC中追加的所有权声明（其实就是所有权修饰符）。</p>

<h4 id="所有权修饰符">所有权修饰符</h4>

<p>Objective-C中为了处理对象，可将变量类型定义为id类型或各种对象类型。所谓对象类型就是指向NSObject这样的Objective-C类的之神，例如“NSObject *”。id类型用于隐藏对象类型的类名部分，相当于C语言中常用的void*.
ARC中，id类型和对象类型同C语言其他类型不同，其类型必须附加所有权修饰符，一共有四种：</p>
<ul>
  <li>__strong</li>
  <li>__weak</li>
  <li>__unsafe__unretained</li>
  <li>__autorelease
下面分别来看下这四种修饰符。</li>
</ul>

<h5 id="__strong">__strong</h5>

<p>ARC中所有id类型和对象类型的默认修饰符是__strong。下面通过代码来看下__strong的应用：</p>

<p>```id obj = [[NSObject alloc]init];
	id __strong obj = [[NSObject alloc]init];
	//这两种在ARC下是等效的。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
上面两种写法看不出\_\_strong有什么作用，我们通过下面的代码来看下。
	
```{
	    //自己生成并持有对象
	    id __strong obj = [[NSObject alloc]init];
	}
	    //超出作用域，强引用失效，自动释放自己持有的对象
	//上面的代码和下面在MRC环境的代码等效
	{
	    id obj = [[NSObject alloc]init];
	    [obj release];
	}

</code></pre></div></div>
<p>如上面的代码所示，附有__strong修饰符的变量obj在超出其变量作用域时，强引用失效，释放其持有的对象。所以__strong的作用就是持有对象，持有的意思就是会导致对象的引用计数+1，当变量指向其他对象或超过作用域后，会释放其持有的对象，对象的引用计数-1。所以通过__strong修饰符，不必再次键入retain或者release，完美的满足了内存管理的思考方式。</p>

<h5 id="__weak">__weak</h5>

<p>看起来好像通过__strong就能完美的进行内存管理，但是遗憾的是，仅仅通过__strong是不能解决有些重大问题的，比如“循环引用”，什么时候会循环引用呢，我们举个例子：</p>

<p><code class="highlighter-rouge">	<span class="k">@interface</span> <span class="nc">Test</span> <span class="p">:</span> <span class="nc">NSObject</span>
	<span class="p">{</span>
	    <span class="n">id</span> <span class="n">__strong</span> <span class="n">obj_</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setObject</span><span class="o">:</span><span class="p">(</span><span class="n">id</span> <span class="n">__strong</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>
	<span class="k">@end</span>
	<span class="k">@implementation</span> <span class="nc">Test</span>
	<span class="k">-</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">init</span>
	<span class="p">{</span>
	    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nf">init</span><span class="p">];</span>
	    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setObject</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="n">obj</span>
	<span class="p">{</span>
	    <span class="n">obj_</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">@end</span>
<span class="err">以下的代码就会发生循环引用：</span>
	<span class="p">{</span>
	    <span class="n">id</span> <span class="n">test0</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Test</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">init</span><span class="p">];</span><span class="c1">//test0持有对象A
</span>	   <span class="n">id</span> <span class="n">test1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Test</span> <span class="nf">alloc</span><span class="p">]</span><span class="nf">init</span><span class="p">];</span><span class="c1">//test1持有对象B
</span>	         <span class="p">[</span><span class="n">test0</span> <span class="nf">setObject</span><span class="p">:</span><span class="n">test1</span><span class="p">];</span><span class="c1">//对象B的实例变量持有对象A
</span>	         <span class="p">[</span><span class="n">test1</span> <span class="nf">setObject</span><span class="p">:</span><span class="n">test0</span><span class="p">];</span><span class="c1">//对象A的实例变量持有对象B
</span>	<span class="p">}</span>   
	<span class="c1">//超出作用域test0释放对象A的引用，此时持有对象A的是对象B的实例变量
</span>	<span class="c1">//test1释放对对象B的引用，此时持有对象B的是对象A的实例变量
</span>	<span class="c1">//这样就发生了内存泄露（这里解释下内存泄露，内存泄露就是本该释放的对象没有释放，还占用着内存。记得刚开始学习的时候看到内存泄露这个名词不明白什么是内存泄露。）
</span>	</code></p>

<p>像上面这种是两个对象间的循环引用，也可能会出现自己对自己的循环引用如下面的代码：</p>

<p>```id test = [[Test alloc]init];
[test setObject:test];</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
讲了这么多问题，那到底怎么才能避免循环引用呢，看到\_\_strong就会意识到还有\_\_weak，和strong相对应，\_\_weak不持有对象，也就是不会导致对象的引用计数+1。来看下面的代码：

```id __weak obj = [[NSObject alloc]init];
//使用weak修饰的变量不持有对象
	//对象立即被释放。
</code></pre></div></div>

<p>我们可以通过__weak来改变上面的循环引用问题，就是用下面的这种方式来声明实例变量</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	   id __weak obj_;
}
</code></pre></div></div>

<p>__weak还有一个优点，就是持有的对象被废弃，变量自动会置为nil，像这样可以通过使用__weak来避免循环应用，还可以通过检查附有__weak修饰符变量是否为nil来判断对象是否被废弃。（PS: __weak只能在iOS4以上版本使用，在iOS4以下版本用__unsafe__unretain代替）。</p>

<h5 id="__unsafe_unretained">__unsafe_unretained</h5>

<p>__unsafe_unretained和__weak很类似，都不会导致对象的引用计数+1，下面我们看看他们两个有什么不同。</p>

<p>```id __unsafe_unretained obj1;
	        {
	            id __strong ojb0 = [[NSObject alloc]init];//obj0持有对象
	            obj1 = ojb0;//obj1既不持有对象强引用也不持有弱引用
	            NSLog(@”A:%@”,obj1);
	        }
	    //超出obj0作用域，强引用失效，对象无持有者，废弃对象
	        NSLog(@”B:%@”,obj1);
	    //打印结果
	    A:&lt;NSObject: 0x100203700&gt;
	    B:&lt;NSObject: 0x100203700&gt;
	    //obj1所指向的对象已经废弃，所以发生野指针。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
所以使用\_\_unsafe\_unretained和\_\_weak的区别就是某些情况下会发生野指针。那么在什么时候使用\_\_unsafe\_unretained呢，就上上面说的一样，在iOS4之前使用，不过这种情况已经很少啦。

##### \_\_autoreleasing

我们知道在ARC有效时不能调用对象的autorelease实例方法，也不能使用NSAutoreleasePool类，这样一来，虽然autorelease无法直接使用，但实际上，ARC有效时autorelease功能是起作用的。下面通过代码来看下如何在ARC下使用autorelease。

```@autoreleasepool {
	            id __autoreleasing obj = [[NSObject alloc]init];
	        }
</code></pre></div></div>

<p><img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1504884931.png" alt="ARC和MRC比较" />
从上图可以看到这两种是等价的，也就是我们可以在ARC中使用@ autoreleasepool和__autoreleasing来使用autorelease。
但是显式的附加__autoreleasing和显示的附加__strong一样罕见。我们通过实例来看下为什么非显式的使用__autoreleasing修饰符也可以。</p>
<ol>
  <li>如果不是以alloc/new/copy/mutableCopy方法名开头的创建对象的方法，那么自动将返回值的对象注册到autoreleasepool。（ps：init方法返回值对象不注册到autoreleasepool）。比如下面代码取得的对象就是autoreleasepool中的对象。</li>
</ol>

<p>```	@autoreleasepool {     <br />
				 id __strong obj = [NSMutableArray array];
			 }</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
我们看下[NSMutableArray array]具体实现：

``` +(id)array	
		{
			id obj = [[NSMutableArray alloc]init];
		'' return obj;//由于return使得对象超出其作用域，但是作为函数返回值，编译器自动将其注册到autoreleasepool。
		}
</code></pre></div></div>

<ol>
  <li>访问__weak修饰符变量时，实际上必定要访问到autoreleasepool的对象</li>
</ol>

<p>```	    id __weak obj = obj0;
NSLog(@”class = %@”,[obj class]);
//上面代码和下面代码相同
id __weak obj = obj0;
id __autoreleasing tem = obj;
NSLog(@”class = %@”,[tem class]);</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
为什么访问附有\_\_weak修饰符变量时必须访问注册到autoreleasepool的对象呢，因为\_\_weak修饰符只持有弱引用，而在访问引用对象过程中，该对象有可能被废弃。如果把要访问对象注册到autoreleasepool中，那么@autoreleasepool块结束前都能确保对象存在。
1. 最后一个可非显示使用\_\_autoreleasing修饰符的就是二级指针了。比如我们声明一个NSObject \*\*obj,他的默认修饰符就是\_\_autoreleasing。那么在什么时候使用呢，比如我们为了获取详细的错误信息，需要传入NSError对象的指针，而不是使用函数返回值。如以下代码：


```-(BOOL)performOperationWithError:(NSError \*\*)error;
		-(BOOL)performOperationWithError:(NSError \* \_\_autoreleasing\*)error;
	//上面两种写法等价，默认的修饰符为\_\_autoreleasing
</code></pre></div></div>

<p>参数中持有NSError对象指针的方法，虽然为了响应结果，需要生成NSError类对象，但是也必须符合内存管理的思考方式，就是除了alloc/new/copy/mutableCopy外其他方法的返回值对象都会注册到autoreleasepool。
另外通过以下代码看看我们在使用二级指针时应该注意什么：</p>

<p>```NSError *error = nil;
NSError **perror = &amp;error;
//上面的代码会报错，因为所有权修饰符必须一致。所以应该改成下面这样的
NSError *error = nil;
NSError * __strong *perror = &amp;error;
//再来看下函数参数的使用
NSError __strong *error = nil;
[obj performOperationWithError:&amp;error];
//因为所有权修饰符必须一致，但是这个不会报错，是因为编译器自动将代码转换成下面的样子
NSError __strong *error = nil;
NSErro __autoreleasing *tmp = error;
[obj performOperationWithError:&amp;tmp];
//当然也可以显示的指定参数的所有权修饰符为__strong，但是为了在使用参数取得对象时符合内存管理的思考方式，不建议这样做。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
在显示指定\_\_autoreleasing修饰符时，必须注意对象要为自动变量(包括局部变量，函数以及方法参数)，还有无论何时，我们都应该去使用@autoreleasepool块结构去代替NSAutoreleasepool，这样提高了程序的可读性，并且@ autoreleasepool在MRC环境下也有效。调试用的\_objc\_autoreleasePoolPrint()函数无论什么环境都可以调试注册到autoreleasepool上的对象。

#### ARC规则

在ARC下，我们需要遵守一定的规则
- 不能使用retain/release/retainCount/autorelease
这个应该不用解释，因为是自动引用计数，所以这些手动的就不能写啦！
- 不能使用NSAllocateObject/NSDeallocateObject
 ARC下一般通过调用alloc方法生成并持有对象，不能使用上面的两个函数生成和释放对象。
- 需要遵守内存管理的方法命名规则
使用alloc/new/copy/mutableCopy开头方法返回对象时必须返回给调用方所应当持有的对象，并且以init开头的方法必须是实例方法，并且必须返回对象，init方法只是对alloc的对象做了一些初始化。
- 不能显示调用dealloc
无论什么环境，只要对象的引用计数为0就是调用该对象的dealloc方法。但是在ARC环境下，我们在dealloc方法内不需要调用[super dealloc],因为ARC会自动处理。如果调用，编译器会报错。
- 使用@autoreleasepool代替NSAutoreleasePool
在ARC环境下，使用NSAutoreleasePool会报错.
- 不能使用NSZone
无论什么环境，Runtime已经单纯忽略了NSZone。
- 对象类型不能作为C语言的结构体成员
因为C语言没有办法管理结构体成员的生命周期，要把对象类型变量加入到结构体中，可以通过转换为void\*或者附加\_\_unsafe\_unretained。因为\_\_unsafe\_unretained修饰的变量不属于编译器内存管理对象。
- 显式转换id和void\*
在MRC下，像下面代码这样将id变量强制转换成void\*变量并不会出问题。

```id obj = [[NSObject alloc]init];
void *p = obj;
//更近一步用void*变量赋值给id变量中，调用其实例方法，运行时也不会有问题。
id o = p;
[o release];
</code></pre></div></div>
<p>但是在ARC环境下上面代码就会引起错误。因为id类型或对象类型赋值给void*或者逆向赋值时都需要进行特定的转换。如果只是想单纯地赋值，可以使用“__bridge”转换。如下面代码所示：</p>

<p>```id obj = [[NSObject alloc]init];
 void *p = (__bridge void *)(obj);
 id o = (__bridge id)p;
但是像上面这样转换为void*类型，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果转换时不注意对象的所有者，会因为野指针导致程序崩溃。
__bridge转换中还有另外两种转换，分别是“__bridge_retained”和“__bridge_transfer”。__bridge_retained的作用如下面代码所示：
//ARC
id obj = [[NSObject alloc]init];
void *p = (__bridge_retained  void *)(obj);
//MRC
id obj = [[NSObject alloc]init];
void *p = (__bridge_retained  void *)(obj);
[(id)p retain];
通过__bridge_retained转换，obj和p同时持有对象。
__bridge_transfer转换和__bridge_retained提供相反的动作。通过代码来看下：
//ARC <br />
id obj = (__bridge_transfer id)p;
//MRC
id obj = (id)p;
[obj retain];
[(id)p release];</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>可以看到当p赋值给obj后立马就释放了对对象的引用。
如果使用以上两种变换，那么不使用id或对象类型变量也可以生成，持有，以及释放对象，但是ARC中并不推荐使用这种方法，这些转化多数在Objective-C和Core Foundation对象之间的相互转换。（ps:Core Foundation对象主要使用在C语言编写的Core Foundation框架中，并使用引用计数的对象，Core Foundation框架中的release/retain分别是CFRelease/CFRetain，Core Foundation对象和Objective-C对象区别很小，不同的就是由哪个框架生成。无论由哪个框架生成，一旦生成后便能在不同框架中使用。Foundation框架对象可以由Core Foundation框架API释放，反之亦然。两种类型的对象互相转换不需要额外的CPU资源，因此也被称为“免费桥”（Toll-Free Bridge））。
以下函数可用于Objective-C对象和Core Foundation对象之间的相互转换。

</code></pre></div></div>
<p>CFTypeRef CFBridgingRetain(id X){
	            return (__bridge_retained CFTypeRef)X;
	        }
id CFBridgingRelease(CFTypeRef X){
	            return (__bridge_transfer id)X;
	        }</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>下面我们来看下具体使用：

``` CFMutableArrayRef cfObject = NULL;
{
	//变量obj持有对生成并持有对象的强引用
	id obj = [[NSMutableArray alloc]init];
	//通过CFBridgingRetain将对象CFRetain赋值给变量cfObject
	cfObject = CFBridgingRetain(obj);
	CFShow(cfObject);
	printf("retain count = %d\n",CFGetRetainCount(cfObject));
	//对象的引用计数为2
}
	//obj超过作用域，强引用失效引用计数为1
	printf("retain count after the scope = %d\n",CFGetRetainCount(cfObject));
	CFRelease(cfObject);
	//因为将对象CFRelease，所以引用计数为0，将对象废弃。
我们再看下使用\_\_bridge转换代替CFBridgingRetain或\_\_bridge\_retained转换时，源代码会变成什么样呢？
	CFMutableArrayRef cfObject = NULL;
	{
	   //变量obj持有对生成并持有对象的强引用
	   id obj = [[NSMutableArray alloc]init];
	   //因为通过__bridge转换时不改变对象的持有状况，所以引用计数为1
	   cfObject = （__bridge CFMutableArrayRef)obj;
	   CFShow(cfObject);
	   printf("retain count = %d\n",CFGetRetainCount(cfObject));
	//对象的引用计数为1
	}
	//obj超过作用域，强引用失效引用计数为0，将对象废弃，此后访问对象出错！野指针
	printf("retain count after the scope = %d\n",CFGetRetainCount(cfObject));
	CFRelease(cfObject);

</code></pre></div></div>
<p>由此可知，CFBridgingRetain或者__bridge_retained是不可或缺的。
下面我们反过来看下，这次由Core Foundation的API生成并持有对象，将该对象作为NSMutableArray对象来处理。</p>
<pre><code class="language-{">	//变量cfObject生成并持有对象。
	CFMutableArrayRef cfObject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);
	//cfObject对象引用计数为1
	 printf("retain count = %d\n",CFGetRetainCount(cfObject));
	//通过CFBridgingRelease赋值，变量obj持有对象强引用的同时，对象通过CFRelease释放
	id obj = CFBridgingRelease(cfObject);
   printf("retain count after the cast = %d\n",CFGetRetainCount(cfObject));
	
	 //对象的引用计数为1
}
	//obj超过作用域，强引用失效引用计数为0，将对象废弃。
下面我们看看通过\_\_bridge代替会出现什么情况：
{
	 //变量cfObject生成并持有对象。
	 CFMutableArrayRef cfObject = CFArrayCreateMutable(kCFAllocatorDefault, 0, NULL);
	 //cfObject对象引用计数为1
	 printf("retain count = %d\n",CFGetRetainCount(cfObject));
	//通过__bridge赋值，变量obj持有对象强引用
	id obj = (__bridge id)cfObject;
	 printf("retain count after the cast = %d\n",CFGetRetainCount(cfObject));
	
	//对象的引用计数为2
}
	//obj超过作用域，强引用失效引用计数为1，发生内存泄露。
由上面可以看出必须通过CFBridgingRetain/CFBridgingRelease或者\_\_bridge\_retained/\_\_bridge\_transfer转换。

</code></pre>

<h4 id="属性">属性</h4>

<p>ARC时，Objective-C的属性也会发生变化，需要我们加上属性修饰符来声明属性，我们看下属性修饰符和所有权修饰符的对应关系：
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1505010817.png" alt="属性声明的属性与所有权修饰符对应的关系" />
以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符变量中。只有copy不是简单赋值，它赋值是通过NSCopying接口的copyWithZone：方法复制赋值源所生成的对象。</p>

<h4 id="数组">数组</h4>

<p>ARC所有权修饰符在修饰静态修饰符变量时和修饰对象类型变量是相同的。我们主要来看下修饰动态数组时的使用。将附有__strong修饰符的变量作为动态数组使用时，根据不同的需要我们可以选择NSMutableArray，NSMutableDictionary，NSMutableSet等Foundation框架的容器。这些容器会恰当的持有追加的对象并帮助我们管理这些对象。但是在C语言的动态数组中也可以使用附有__strong修饰符的变量，知识必须遵守一些事项，以下按顺序说明。</p>
<ol>
  <li>声明动态数组：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id __strong *array = nil;
 //因为id *默认为__autoreleasing，所以这里显示指定__strong
</code></pre></div>    </div>
  </li>
  <li>使用calloc函数确保想分配的附有__strong修饰符变量的容量占有块</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array = (id __strong *)calloc(entries, sizeof(id));
		//这里分配了entries个所需的内存块。由于使用附有__strong修饰符的变量前必须先将其初始化为nil，所以这里使用使分配区域初始化为0的calloc函数来分配内存。不使用calloc函数，在用malloc函数分配内存后可用memset等函数将内存填充为0，但是，像下面的代码是非常危险的，以内malloc函数分配的内存区域没有被初始化为0，因此nil会被赋值给__strong修饰符并且被赋值了随机地址的变量中，从而释放一个不存在的对象，所以在分配内存是使用calloc函数。
		array = (id __strong *)malloc(sizeof(id) * entries);
		    for (NSUInteger i = 0; i &lt; entries; i++) {
		        array[i] = nil;
		    }
</code></pre></div></div>
<ol>
  <li>通过calloc函数分配的动态数组就能想静态数组一样使用
     <code class="highlighter-rouge">array[0] = [[NSObject alloc]init];</code>
但是在动态数组中操作附有__strong修饰符的变量和静态数组有很大区别，需要自己释放元素，不能只使用free函数释放数组，数组各元素也需要释放。因为在静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，但是在动态数组中，编译器不能确定数组的声明周期所以无法处理。我们需要像下面代码所示去释放数组元素：
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for NSUInteger i = 0; i &lt; entries; i++) {
   array[i] = nil;
}
free(array);
</code></pre></div>    </div>
    <p>同初始化时注意事项相反，即使使用memset函数将内存填充为0也不会释放数组元素对象，只会引起内存泄露，必须赋值为nil。另外使用memcpy和realloc函数重新分配内存块也会有危险，由于数组元素赋值的对象有可能被保留在内存中或是重复被废弃，所以这两个函数也禁止使用。最好不要用__autoreleasing修饰符去修饰动态数组。由于__unsafe_unretained修饰在编译器内存管理对象之外，所以它与void *类型一样，只能作为C语言的指针类型来使用。</p>
  </li>
</ol>

<h4 id="arc实现">ARC实现</h4>

<p>苹果官方说明中称，ARC是由编译器进行内存管理的，其实编译器是无法完全胜任的，还需要Runtime的协助。</p>

<h5 id="__strong实现">__strong实现</h5>

<p>我们通过clang可以看到程序的汇编输出，通过汇编输出和objc4库的源代码就能够知道程序是怎么工作的，我们来看下下面代码是怎么工作的：</p>

<pre><code class="language-{"> id __strong obj = [[NSObject alloc]init];
}
//编译器的模拟代码如下：
id obj = objc_msgSend(NSObject,@selector(alloc));
objc_msgSend(obj,@selector(init));
objc_release(obj);
通过上面代码可以看到编译器自动调用了release。下面再来看下不是通过alloc/new/copy/mutableCopy方法创建对象会是什么情况：
{
	id __strong obj = [NSMutableArray array];
}
	//编译器模拟代码
id obj = objc_msgSend(NSMutableArray,@selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_release(obj);

</code></pre>
<p>这里稍有不同的是objc_retainAutoreleasedReturnValue函数是什么呢，其实objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行。他的意思就是持有的对象是返回注册到autoreleasepool中对象的方法，或是函数的返回值。与objc_retainAutoreleasedReturnValue函数相对的函数是objc_autoreleaseReturnValue.下面我们来看下他的用法：</p>

<pre><code class="language-+(id)array">{
	 return [[NSMutableArray alloc] init];
}
//转换后的源代码使用了objc\_autoreleaseReturnValue
+(id)array
{
	id obj = objc_msgSend(NSMutableArray.@selector(alloc));
	objc_msgSend(obj,@selector(init));
	return objc_autoreleaseReturnValue(obj);
}
</code></pre>

<p>objc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，如果方法或函数的调用方在调用了方法或函数后紧接着调用了objc_retainAutoreleasedReturnValue函数，那么就不将返回的对象注册到autoreleasepool中，而是直接传递到方法或函数的调用方。（ps:在objc4版本493.9中，只能在OS X64位中最优化）如下图所示:
<img src="https://nightwish.oss-cn-beijing.aliyuncs.com/1505025357.png" alt="省略了autoreleasepool注册" /></p>

<h5 id="__weak实现">__weak实现</h5>

<p>我们先来看下__weak的功能：</p>
<ul>
  <li>若附有__weak修饰符的变量所引用的对象被废弃，自动置为nil。</li>
  <li>使用__weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</li>
</ul>

<p>```		id __weak obj1 = obj;
//转换后的源代码
id obj1 ;
objc_initWeak(&amp;obj1,obj);
objc_destroyWeak(&amp;obj1);</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objc\_initWeak函数初始化附有\_\_weak修饰符的变量，在变量作用域结束时通过objc\_destroyWeak函数释放变量。那么objc\_initWeak又是怎么初始化的呢？我们看下面代码：
```obj1 = 0;
objc_storeWeak(&amp;obj1,obj)；
//objc_initWeak首先将obj1初始化为0，然后再通过objc_storeWeak函数赋值给obj1。
//objc_destoryWeak函数将0作为参数调用objc_storeWeak函数，释放变量
bjc_storeWeak(&amp;obj1,0)；
</code></pre></div></div>
<p>objc_storeWeak函数把第二个参数的赋值对象作为键值，将第一参数的附有__weak修饰符的变量的地址注册到weak表中，如果第二个参数为0，则把变量的地址从weak表中移除。
下面我么来看下对象废弃的动作：</p>
<ol>
  <li>objc_release</li>
  <li>引用计数为0所以执行dealloc</li>
  <li>_objc_rootDealloc</li>
  <li>object_dispose</li>
  <li>objc_destructInstance</li>
  <li>objc_clear_deallocating
对象被废弃是调用objc_clear_deallocating的动作如下：</li>
  <li>从weak表中获取废弃对象的地址为键值的记录。</li>
  <li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li>
  <li>从weak表中删除该记录。</li>
  <li>从引用计数表中删除废弃对象的地址为键值的记录。
根据上面的步骤，前面说的如果附有__weak修饰符变量所引用的对象被废弃，则将nil赋值给该变量这一功能被实现，但是如果大量使用附有__weak修饰符的变量，则会消耗响应的CPU资源。我们只在需要避免循环引用是使用__weak修饰符。
下面我么来验证第二个功能：使用__weak修饰符的变量即是使用注册到autoreleasepool中的对象。</li>
</ol>

<p>```id __weak obj1 = obj;
NSLog(@”%@”,obj1);
//该源代码转换成如下形式
id obj1;
objc_initWeak(&amp;obj1,obj);
id tmp = objc_loadWeakRetained(&amp;obj1);
objc_autorelease(tmp);
NSLog(@”%@”,tmp);
objc_destroyWeak(&amp;obj1);</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>相比于前面的情形，增加了objc\_loadWeakRetained函数和objc\_autorelease函数，这些函数调用动作如下：
1. objc\_loadWeakRetained函数取出附有\_\_weak修饰符变量所引用的对象，并且retain。
2. objc\_autorelease函数将对象注册到autoreleasepool中。
如果大量使用附有\_\_weak修饰符的变量，注册到autoreleasepool的对象也会大量增加，因此在使用附有\_\_weak修饰符的变量，最好先暂时赋值给\_\_strong修饰符的变量后再使用。

##### \_\_autoreleasing实现

</code></pre></div></div>
<p>@autoreleasepool {
    id __autoreleasing obj = [[NSObject alloc]init];
}
	//转换成如下形式
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSObject,@selector(alloc));
objc_msgSend(obj,@selector(init));
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这与苹果的autorelease实现中的说明完全相同。我们再来看下在autoreleasepool块中使用注册到autoreleasepool中的对象会如何。
</code></pre></div></div>
<p>@autoreleasepool {         <br />
	id __autoreleasing obj = [NSMutableArray array];
}
	//转换成如下形式
	id pool = objc_autoreleasePoolPush();
	id obj = objc_msgSend(NSMutableArray,@selector(array));
	objc_retainAutoreleasedReturnValue(obj);
	objc_autorelease(obj);
	objc_autoreleasePoolPop(pool);
```
虽然持有对象的方法从alloc变为objc_retainAutoreleasedReturnValue函数，但注册autoreleasepool的方法没有改变，仍是objc_autorelease函数。</p>

<h4 id="引用计数-1">引用计数</h4>

<p>前面我们一直都在说的是引用计数管理的思考方式，没有过多的去关注引用计数的值，我们可以通过_objc_rootRetainCount(id obj)函数获取引用计数的值，但实际上并不能够完全信任该函数取得的值。对于已经释放的对象以及不正确的对象地址，有时也会返回1。另外在多线程中使用对象的引用计数数值，因为存有竞态条件的问题，所以取得的数值不一定完全可信。虽然在调试中_objc_rootRetainCount(id obj)很有用，但最好在了解其所具有的问题的基础上来使用。</p>

<h3 id="感悟">感悟</h3>

<p>平常我们写代码可能不会去想这些东西，但是我们一定需要了解这些东西，因为一旦出现问题，这些东西会让我们在分析问题，处理问题上更加得心应手。了解了一个东西，我们再去使用它。就像使用第三方库时，我们应该先了解再去使用，不应该只是看看他的API直接就用了，这样我们一点收获都没有。我们也没必要重复的去造轮子，了解了就可以拿来用。知其然，知其所以然，这一点是我们应该做到的。</p>


	  ]]></description>
	</item>


</channel>
</rss>
